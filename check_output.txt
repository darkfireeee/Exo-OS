warning: unused import: `core::convert::TryInto`
 --> libs\exo_crypto\src\chacha20.rs:4:5
  |
4 | use core::convert::TryInto;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `aad`
   --> libs\exo_crypto\src\chacha20.rs:283:23
    |
283 | fn poly1305(m: &[u8], aad: &[u8], key: &[u8; POLY1305_KEYBYTES]) -> [u8; POLY1305_TAGBYTES] {
    |                       ^^^ help: if this is intentional, prefix it with an underscore: `_aad`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: exo-kernel@0.2.0: Compiled boot.asm with NASM (path src/arch/x86_64/boot/boot.asm)
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled serial.c
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled windowed.S (provides context_switch symbol)
warning: `exo_crypto` (lib) generated 2 warnings (run `cargo fix --lib -p exo_crypto` to apply 1 suggestion)
warning: fields `path`, `size`, and `extra_flags` are never read
  --> libs\exo_types\src\capability.rs:67:5
   |
65 | pub struct CapabilityMetadata {
   |            ------------------ fields in this struct
66 |     /// Chemin ou nom pour les objets nomm├⌐s
67 |     path: Option<String>,
   |     ^^^^
...
70 |     size: Option<usize>,
   |     ^^^^
...
73 |     extra_flags: u32,
   |     ^^^^^^^^^^^
   |
   = note: `CapabilityMetadata` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `core::mem::MaybeUninit`
 --> libs\exo_ipc\src\channel.rs:5:5
  |
5 | use core::mem::MaybeUninit;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `MAX_INLINE_SIZE`, `MessageFlags`, and `MessageHeader`
 --> libs\exo_ipc\src\channel.rs:9:22
  |
9 | use crate::{Message, MessageFlags, MessageHeader, MAX_INLINE_SIZE, SLOT_SIZE};
  |                      ^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused import: `core::mem::size_of`
 --> libs\exo_ipc\src\message.rs:4:5
  |
4 | use core::mem::size_of;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused variable: `size`
   --> libs\exo_ipc\src\channel.rs:252:24
    |
252 | unsafe fn alloc_zeroed(size: usize) -> *mut u8 {
    |                        ^^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
252 | unsafe fn alloc_zeroed(_size: usize) -> *mut u8 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `SLOT_ALIGN`
    |
252 - unsafe fn alloc_zeroed(size: usize) -> *mut u8 {
252 + unsafe fn alloc_zeroed(SLOT_ALIGN: usize) -> *mut u8 {
    |

warning: field `capacity` is never read
  --> libs\exo_ipc\src\channel.rs:30:5
   |
28 | struct RingBuffer<T> {
   |        ---------- field in this struct
29 |     buffer: *mut T,
30 |     capacity: usize,
   |     ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `capacity` is never read
   --> libs\exo_ipc\src\channel.rs:101:5
    |
 90 | pub struct Channel<T> {
    |            ------- field in this struct
...
101 |     capacity: usize,
    |     ^^^^^^^^

warning: `exo_types` (lib) generated 1 warning
warning: `exo_ipc` (lib) generated 6 warnings (run `cargo fix --lib -p exo_ipc` to apply 4 suggestions)
    Checking exo-kernel v0.2.0 (C:\Users\Eric\Documents\Exo-OS\kernel)
error[E0433]: failed to resolve: unresolved import
   --> kernel\src\arch\x86_64\interrupts\apic.rs:266:16
    |
266 |         crate::time::sleep(1000);
    |                ^^^^
    |                |
    |                unresolved import
    |                help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\arch\x86_64\syscall.rs:70:23
   |
70 |     let args = crate::syscall::abi::SyscallArgs {
   |                       ^^^^^^^
   |                       |
   |                       unresolved import
   |                       help: a similar path exists: `arch::syscall`

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\boot\early_init.rs:11:11
   |
11 |     arch::current_arch::init_gdt()
   |           ^^^^^^^^^^^^
   |           |
   |           expected type, found function `current_arch` in `arch`
   |           help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\boot\early_init.rs:16:11
   |
16 |     arch::current_arch::init_idt()
   |           ^^^^^^^^^^^^
   |           |
   |           expected type, found function `current_arch` in `arch`
   |           help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:47:21
   |
47 |     if let Err(e) = drivers::timer::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:53:21
   |
53 |     if let Err(e) = drivers::serial::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:59:21
   |
59 |     if let Err(e) = drivers::keyboard::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `posix` in the crate root
  --> kernel\src\boot\late_init.rs:72:12
   |
72 |     crate::posix::init();
   |            ^^^^^ could not find `posix` in the crate root

error[E0433]: failed to resolve: could not find `security` in the crate root
   --> kernel\src\boot\late_init.rs:103:12
    |
103 |     crate::security::capabilities::init();
    |            ^^^^^^^^ could not find `security` in the crate root

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\late_init.rs:112:12
    |
112 |     crate::time::start_timer_service();
    |            ^^^^
    |            |
    |            unresolved import
    |            help: a similar path exists: `core::time`

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\recovery.rs:71:47
   |
71 |     if let Some(event) = crate::arch::x86_64::c_compat::keyboard_read_event() {
   |                                               ^^^^^^^^ could not find `c_compat` in `x86_64`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\boot\mod.rs:84:29
   |
84 |     let boot_start = crate::time::get_time();
   |                             ^^^^
   |                             |
   |                             unresolved import
   |                             help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\boot\mod.rs:89:32
   |
89 |     let critical_time = crate::time::get_time() - boot_start;
   |                                ^^^^
   |                                |
   |                                unresolved import
   |                                help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\boot\mod.rs:99:30
   |
99 |     let normal_time = crate::time::get_time() - boot_start - critical_time;
   |                              ^^^^
   |                              |
   |                              unresolved import
   |                              help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\mod.rs:109:29
    |
109 |     let total_time = crate::time::get_time() - boot_start;
    |                             ^^^^
    |                             |
    |                             unresolved import
    |                             help: a similar path exists: `core::time`

error[E0433]: failed to resolve: could not find `fs` in the crate root
   --> kernel\src\memory\dma.rs:337:23
    |
337 |     let file = crate::fs::get_file_descriptor(fd)?;
    |                       ^^ could not find `fs` in the crate root

error[E0433]: failed to resolve: could not find `fs` in the crate root
   --> kernel\src\memory\mmap.rs:337:23
    |
337 |     let file = crate::fs::get_file_descriptor(fd)?;
    |                       ^^ could not find `fs` in the crate root

error[E0433]: failed to resolve: could not find `process` in the crate root
   --> kernel\src\memory\protection.rs:395:16
    |
395 |         crate::process::terminate_current_process(1);
    |                ^^^^^^^ could not find `process` in the crate root

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\panic.rs:28:22
   |
28 |         crate::arch::current_arch::print_backtrace(&mut logger);
   |                      ^^^^^^^^^^^^
   |                      |
   |                      expected type, found function `current_arch` in `arch`
   |                      help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\panic.rs:32:34
   |
32 |     if let Err(e) = crate::arch::current_arch::shutdown() {
   |                                  ^^^^^^^^^^^^
   |                                  |
   |                                  expected type, found function `current_arch` in `arch`
   |                                  help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
  --> kernel\src\logger.rs:95:20
   |
95 |     serial: crate::c_compat::SerialPort,
   |                    ^^^^^^^^ could not find `c_compat` in the crate root

error[E0425]: cannot find value `ap_id` in this scope
  --> kernel\src\arch\x86_64\cpu\smp.rs:69:9
   |
69 |         ap_id,
   |         ^^^^^ not found in this scope

error[E0425]: cannot find function `alloc_page` in module `crate::memory`
   --> kernel\src\arch\x86_64\memory\numa.rs:159:24
    |
159 |         crate::memory::alloc_page(flags)
    |                        ^^^^^^^^^^ help: a function with a similar name exists: `alloc_pages`
    |
   ::: kernel\src\memory\physical\mod.rs:317:1
    |
317 | pub fn allocate_frame() -> MemoryResult<Frame> {
    | ---------------------------------------------- similarly named function `alloc_pages` defined here

error[E0425]: cannot find value `HEAP` in module `crate::memory`
   --> kernel\src\arch\x86_64\memory\mod.rs:112:20
    |
112 |     crate::memory::HEAP.lock().replace(heap);
    |                    ^^^^ not found in `crate::memory`

error[E0425]: cannot find function `map_pages` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\apic.rs:108:24
    |
108 |         crate::memory::map_pages(
    |                        ^^^^^^^^^ not found in `crate::memory`

error[E0425]: cannot find function `map_pages` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:123:24
    |
123 |         crate::memory::map_pages(
    |                        ^^^^^^^^^ not found in `crate::memory`

error[E0425]: cannot find function `kernel_virt_to_phys` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:124:28
    |
124 |             crate::memory::kernel_virt_to_phys(ioapic_addr as usize),
    |                            ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory`

error[E0425]: cannot find function `detect_cpus` in module `cpu::smp`
   --> kernel\src\arch\x86_64\mod.rs:175:19
    |
175 |         cpu::smp::detect_cpus();
    |                   ^^^^^^^^^^^ not found in `cpu::smp`
    |
help: consider importing this function
    |
 19 + use crate::boot::early_init::detect_cpus;
    |
help: if you import `detect_cpus`, refer to it directly
    |
175 -         cpu::smp::detect_cpus();
175 +         detect_cpus();
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:123:22
    |
123 |                 1 => MemoryType::Usable,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:124:22
    |
124 |                 2 => MemoryType::Reserved,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:125:22
    |
125 |                 3 => MemoryType::ACPI,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:126:22
    |
126 |                 4 => MemoryType::NVS,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:127:22
    |
127 |                 _ => MemoryType::BadMemory,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0422]: cannot find struct, variant or union type `MemoryRegion` in this scope
   --> kernel\src\boot\multiboot2.rs:130:26
    |
130 |             let region = MemoryRegion {
    |                          ^^^^^^^^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  6 + use crate::arch::x86_64::MemoryRegion;
    |
  6 + use crate::memory::physical::zone::MemoryRegion;
    |
  6 + use crate::memory::vm::MemoryRegion;
    |

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\early_init.rs:39:43
   |
39 |     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
   |                                           ^^^^^^^^ could not find `c_compat` in `x86_64`
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
39 -     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
39 +     let mut serial = SerialPort::new(0x3F8);
   |

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\recovery.rs:78:43
   |
78 |     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
   |                                           ^^^^^^^^ could not find `c_compat` in `x86_64`
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
78 -     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
78 +     let mut serial = SerialPort::new(0x3F8);
   |

error[E0425]: cannot find function `inb` in module `arch::x86_64::io`
   --> kernel\src\boot\recovery.rs:171:34
    |
171 |         while (arch::x86_64::io::inb(0x64) & 0x02) != 0 {}
    |                                  ^^^ not found in `arch::x86_64::io`
    |
note: function `crate::arch::x86_64::pic::inb` exists but is inaccessible
   --> kernel\src\arch\x86_64\interrupts\pic.rs:135:1
    |
135 | unsafe fn inb(port: u16) -> u8 {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible

error[E0425]: cannot find function `outb` in module `arch::x86_64::io`
   --> kernel\src\boot\recovery.rs:174:27
    |
174 |         arch::x86_64::io::outb(0x64, 0xFE);
    |                           ^^^^ not found in `arch::x86_64::io`
    |
note: function `crate::arch::x86_64::pic::outb` exists but is inaccessible
   --> kernel\src\arch\x86_64\interrupts\pic.rs:130:1
    |
130 | unsafe fn outb(port: u16, value: u8) {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible

error[E0425]: cannot find function `outw` in module `arch::x86_64::io`
   --> kernel\src\boot\recovery.rs:195:27
    |
195 |         arch::x86_64::io::outw(0x604, 0x2000);
    |                           ^^^^ not found in `arch::x86_64::io`

error[E0425]: cannot find function `critical_phase` in module `phases`
  --> kernel\src\boot\mod.rs:87:13
   |
87 |     phases::critical_phase(boot_info)?;
   |             ^^^^^^^^^^^^^^ not found in `phases`

error[E0425]: cannot find function `normal_phase` in module `phases`
  --> kernel\src\boot\mod.rs:97:13
   |
97 |     phases::normal_phase(boot_info)?;
   |             ^^^^^^^^^^^^ not found in `phases`

error[E0425]: cannot find function `deferred_phase` in module `phases`
   --> kernel\src\boot\mod.rs:107:13
    |
107 |     phases::deferred_phase(boot_info)?;
    |             ^^^^^^^^^^^^^^ not found in `phases`

error[E0433]: failed to resolve: could not find `numa` in `arch`
   --> kernel\src\memory\physical\numa.rs:179:31
    |
179 |         let numa_info = arch::numa::detect_numa_topology()?;
    |                               ^^^^ could not find `numa` in `arch`
    |
help: consider importing this module
    |
  8 + use crate::arch::memory::numa;
    |
help: if you import `numa`, refer to it directly
    |
179 -         let numa_info = arch::numa::detect_numa_topology()?;
179 +         let numa_info = numa::detect_numa_topology()?;
    |

error[E0425]: cannot find function `cpu_count` in module `arch::cpu`
   --> kernel\src\memory\physical\numa.rs:214:41
    |
214 |             for cpu_id in 0..arch::cpu::cpu_count() {
    |                                         ^^^^^^^^^
    |
   ::: kernel\src\arch\x86_64\cpu\mod.rs:47:1
    |
 47 | static CPU_COUNT: AtomicUsize = AtomicUsize::new(1); // BSP is always CPU 0
    | ---------------------------------------------------- similarly named static `CPU_COUNT` defined here
    |
help: a static with a similar name exists
    |
214 -             for cpu_id in 0..arch::cpu::cpu_count() {
214 +             for cpu_id in 0..arch::cpu::CPU_COUNT() {
    |
help: consider importing this function
    |
  8 + use crate::arch::x86_64::smp::cpu_count;
    |
help: if you import `cpu_count`, refer to it directly
    |
214 -             for cpu_id in 0..arch::cpu::cpu_count() {
214 +             for cpu_id in 0..cpu_count() {
    |

error[E0425]: cannot find value `DEFAULT_ALIGNMENT` in this scope
   --> kernel\src\memory\heap\hybrid_allocator.rs:109:57
    |
109 |         if size <= SMALL_ALLOC_MAX_SIZE && alignment <= DEFAULT_ALIGNMENT {
    |                                                         ^^^^^^^^^^^^^^^^^ not found in this scope
    |
help: consider importing this constant
    |
  7 + use crate::memory::heap::DEFAULT_ALIGNMENT;
    |

error[E0425]: cannot find value `DEFAULT_ALIGNMENT` in this scope
   --> kernel\src\memory\heap\cpu_slab.rs:476:30
    |
476 |         cpu_slab.alloc(size, DEFAULT_ALIGNMENT)
    |                              ^^^^^^^^^^^^^^^^^ not found in this scope
    |
help: consider importing this constant
    |
  7 + use crate::memory::heap::DEFAULT_ALIGNMENT;
    |

error[E0412]: cannot find type `String` in this scope
   --> kernel\src\memory\heap\statistics.rs:269:38
    |
269 |     pub fn generate_report(&self) -> String {
    |                                      ^^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  6 + use crate::prelude::String;
    |
  6 + use alloc::string::String;
    |

error[E0412]: cannot find type `Vec` in this scope
  --> kernel\src\memory\shared\descriptor.rs:21:22
   |
21 |     physical_frames: Vec<PhysicalAddress>,
   |                      ^^^ not found in this scope
   |
help: consider importing one of these structs
   |
 6 + use crate::prelude::vec::Vec;
   |
 6 + use alloc::vec::Vec;
   |

error[E0412]: cannot find type `Vec` in this scope
  --> kernel\src\memory\shared\descriptor.rs:32:26
   |
32 |         physical_frames: Vec<PhysicalAddress>,
   |                          ^^^ not found in this scope
   |
help: consider importing one of these structs
   |
 6 + use crate::prelude::vec::Vec;
   |
 6 + use alloc::vec::Vec;
   |

error[E0433]: failed to resolve: could not find `MemoryRegionType` in `virtual_mem`
   --> kernel\src\memory\shared\mod.rs:122:41
    |
122 |             crate::memory::virtual_mem::MemoryRegionType::Mmap,
    |                                         ^^^^^^^^^^^^^^^^ could not find `MemoryRegionType` in `virtual_mem`
    |
help: a struct with a similar name exists
    |
122 -             crate::memory::virtual_mem::MemoryRegionType::Mmap,
122 +             crate::memory::virtual_mem::MemoryRegion::Mmap,
    |
help: consider importing one of these enums
    |
  7 + use crate::memory::physical::zone::MemoryRegionType;
    |
  7 + use crate::memory::vm::address_space::MemoryRegionType;
    |
help: if you import `MemoryRegionType`, refer to it directly
    |
122 -             crate::memory::virtual_mem::MemoryRegionType::Mmap,
122 +             MemoryRegionType::Mmap,
    |

error[E0433]: failed to resolve: could not find `MemoryRegionInfo` in `virtual_mem`
   --> kernel\src\memory\shared\mod.rs:123:41
    |
123 |             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
    |                                         ^^^^^^^^^^^^^^^^ could not find `MemoryRegionInfo` in `virtual_mem`
    |
help: a struct with a similar name exists
    |
123 -             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
123 +             crate::memory::virtual_mem::MemoryRegion::Mmap {
    |
help: consider importing this enum
    |
  7 + use crate::memory::vm::address_space::MemoryRegionInfo;
    |
help: if you import `MemoryRegionInfo`, refer to it directly
    |
123 -             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
123 +             MemoryRegionInfo::Mmap {
    |

error[E0412]: cannot find type `Vec` in this scope
   --> kernel\src\memory\shared\mod.rs:186:54
    |
186 |     pub fn list_shared_memory(&self) -> MemoryResult<Vec<SharedMemoryInfo>> {
    |                                                      ^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0433]: failed to resolve: use of undeclared type `Vec`
   --> kernel\src\memory\shared\mod.rs:189:38
    |
189 |         let mut shared_memory_list = Vec::new();
    |                                      ^^^ use of undeclared type `Vec`
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0412]: cannot find type `Vec` in this scope
   --> kernel\src\memory\shared\mod.rs:301:45
    |
301 | pub fn list_shared_memory() -> MemoryResult<Vec<SharedMemoryInfo>> {
    |                                             ^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0425]: cannot find function `dealloc_aligned` in module `crate::memory::heap`
   --> kernel\src\memory\cache.rs:224:26
    |
224 |     crate::memory::heap::dealloc_aligned(aligned_data);
    |                          ^^^^^^^^^^^^^^^ help: a function with a similar name exists: `alloc_aligned`
    |
   ::: kernel\src\memory\heap\mod.rs:166:1
    |
166 | pub fn alloc_aligned(size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
    | -------------------------------------------------------------------------------- similarly named function `alloc_aligned` defined here

error[E0425]: cannot find function `physical_to_virtual` in module `crate::memory::virtual_mem`
   --> kernel\src\memory\dma.rs:365:56
    |
365 |         let virtual_addr = crate::memory::virtual_mem::physical_to_virtual(physical_frame.address())?;
    |                                                        ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory::virtual_mem`

error[E0425]: cannot find function `physical_to_virtual` in module `crate::memory::virtual_mem`
   --> kernel\src\memory\mmap.rs:365:56
    |
365 |         let virtual_addr = crate::memory::virtual_mem::physical_to_virtual(physical_frame.address())?;
    |                                                        ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory::virtual_mem`

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
  --> kernel\src\logger.rs:86:37
   |
86 |             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
   |                                     ^^^^^^^^ could not find `c_compat` in the crate root
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
86 -             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
86 +             let mut serial = SerialPort::new(0x3F8);
   |

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
   --> kernel\src\logger.rs:100:33
    |
100 |         let mut serial = crate::c_compat::SerialPort::new(0x3F8);
    |                                 ^^^^^^^^ could not find `c_compat` in the crate root
    |
help: consider importing this struct
    |
  6 + use uart_16550::SerialPort;
    |
help: if you import `SerialPort`, refer to it directly
    |
100 -         let mut serial = crate::c_compat::SerialPort::new(0x3F8);
100 +         let mut serial = SerialPort::new(0x3F8);
    |

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
   --> kernel\src\logger.rs:129:37
    |
129 |             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
    |                                     ^^^^^^^^ could not find `c_compat` in the crate root
    |
help: consider importing this struct
    |
  6 + use uart_16550::SerialPort;
    |
help: if you import `SerialPort`, refer to it directly
    |
129 -             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
129 +             let mut serial = SerialPort::new(0x3F8);
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\mod.rs:425:22
    |
425 | pub use page_table::{PageTableFlags as VmFlags}; // Alias VmFlags
    |                      ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: import `PageTableFlags` directly
    |
425 - pub use page_table::{PageTableFlags as VmFlags}; // Alias VmFlags
425 + pub use page_table::{memory::virtual_mem::PageTableFlags}; // Alias VmFlags
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\address_space.rs:192:44
    |
192 |             let flags = super::page_table::PageTableFlags::new()
    |                                            ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
192 -             let flags = super::page_table::PageTableFlags::new()
192 +             let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
192 -             let flags = super::page_table::PageTableFlags::new()
192 +             let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\address_space.rs:201:48
    |
201 |                 let flags = super::page_table::PageTableFlags::new()
    |                                                ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
201 -                 let flags = super::page_table::PageTableFlags::new()
201 +                 let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
201 -                 let flags = super::page_table::PageTableFlags::new()
201 +                 let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: tuple struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:157:48
    |
157 |                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |                                                ^^^^^^^^^^^^^^ private tuple struct import
    |
note: the tuple struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the tuple struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider importing this tuple struct instead
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = crate::memory::virtual_mem::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:157:93
    |
157 |                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |                                                                                             ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = super::page_table::PageTableFlags(flags.0 & !crate::memory::vm::PageTableFlags::new().cow().0);
    |
help: import `PageTableFlags` directly
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = super::page_table::PageTableFlags(flags.0 & !memory::virtual_mem::PageTableFlags().cow().0);
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:195:40
    |
195 |         let flags = super::page_table::PageTableFlags::new()
    |                                        ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
195 -         let flags = super::page_table::PageTableFlags::new()
195 +         let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
195 -         let flags = super::page_table::PageTableFlags::new()
195 +         let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\dma.rs:416:82
    |
416 | fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
    |                                                                                  ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> crate::memory::PageProtection {
    |
help: import `PageProtection` through the re-export
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> memory::PageProtection {
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\dma.rs:417:49
    |
417 |     let mut flags = crate::memory::virtual_mem::PageProtection::new();
    |                                                 ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = crate::memory::PageProtection::new();
    |
help: import `PageProtection` through the re-export
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = memory::PageProtection();
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\mmap.rs:416:82
    |
416 | fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
    |                                                                                  ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> crate::memory::PageProtection {
    |
help: import `PageProtection` through the re-export
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> memory::PageProtection {
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\mmap.rs:417:49
    |
417 |     let mut flags = crate::memory::virtual_mem::PageProtection::new();
    |                                                 ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = crate::memory::PageProtection::new();
    |
help: import `PageProtection` through the re-export
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = memory::PageProtection();
    |

warning: the feature `core_intrinsics` is internal to the compiler or standard library
  --> kernel\src\lib.rs:10:12
   |
10 | #![feature(core_intrinsics)]
   |            ^^^^^^^^^^^^^^^
   |
   = note: using it is strongly discouraged
   = note: `#[warn(internal_features)]` on by default

warning: unused `#[macro_use]` import
  --> kernel\src\lib.rs:13:1
   |
13 | #[macro_use]
   | ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused `#[macro_use]` import
  --> kernel\src\lib.rs:15:1
   |
15 | #[macro_use]
   | ^^^^^^^^^^^^

warning: unused import: `super::cpuid`
 --> kernel\src\arch\x86_64\cpu\features.rs:9:5
  |
9 | use super::cpuid;
  |     ^^^^^^^^^^^^

warning: unused imports: `read_msr` and `write_msr`
 --> kernel\src\arch\x86_64\cpu\power.rs:6:38
  |
6 | use crate::arch::x86_64::registers::{read_msr, write_msr};
  |                                      ^^^^^^^^  ^^^^^^^^^

warning: unused doc comment
  --> kernel\src\arch\x86_64\memory\mod.rs:42:1
   |
42 | /// Page table flags
   | ^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
   = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `UnmapError`
 --> kernel\src\arch\x86_64\memory\paging.rs:6:34
  |
6 | use super::{MapError, PageFlags, UnmapError};
  |                                  ^^^^^^^^^^

warning: unused import: `super::paging`
  --> kernel\src\arch\x86_64\memory\numa.rs:14:5
   |
14 | use super::paging;
   |     ^^^^^^^^^^^^^

warning: unused imports: `GlobalAlloc` and `Layout`
  --> kernel\src\arch\x86_64\memory\mod.rs:11:19
   |
11 | use core::alloc::{GlobalAlloc, Layout};
   |                   ^^^^^^^^^^^  ^^^^^^

warning: unused import: `core::ptr::NonNull`
  --> kernel\src\arch\x86_64\memory\mod.rs:12:5
   |
12 | use core::ptr::NonNull;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::memory::frame_allocator::FrameAllocator`
  --> kernel\src\arch\x86_64\memory\mod.rs:14:5
   |
14 | use crate::memory::frame_allocator::FrameAllocator;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `bit_field::BitField`
 --> kernel\src\arch\x86_64\interrupts\idt.rs:6:5
  |
6 | use bit_field::BitField;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `core::arch::asm`
 --> kernel\src\arch\x86_64\interrupts\apic.rs:6:5
  |
6 | use core::arch::asm;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `virt_to_phys`
  --> kernel\src\arch\x86_64\interrupts\apic.rs:10:48
   |
10 | use crate::memory::{alloc_pages, phys_to_virt, virt_to_phys, PageFlags};
   |                                                ^^^^^^^^^^^^

warning: unused imports: `phys_to_virt` and `virt_to_phys`
  --> kernel\src\arch\x86_64\interrupts\ioapic.rs:13:21
   |
13 | use crate::memory::{phys_to_virt, virt_to_phys};
   |                     ^^^^^^^^^^^^  ^^^^^^^^^^^^

warning: ambiguous glob re-exports
  --> kernel\src\arch\x86_64\mod.rs:32:9
   |
32 | pub use cpu::*;
   |         ^^^^^^ the name `init` in the value namespace is first re-exported here
33 | pub use memory::*;
34 | pub use interrupts::*;
   |         ------------- but the name `init` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:53:1
   |
53 | /// CR0 register flags
   | ^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:70:1
   |
70 | /// CR4 register flags
   | ^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:95:1
   |
95 | /// RFLAGS register flags
   | ^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
   --> kernel\src\arch\x86_64\registers.rs:307:1
    |
307 | /// EFER register flags
    | ^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
    |
    = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `cpu::topology::CpuTopology`
  --> kernel\src\arch\x86_64\mod.rs:46:5
   |
46 | use cpu::topology::CpuTopology;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `cpu::features::CpuFeatures`
  --> kernel\src\arch\x86_64\mod.rs:47:5
   |
47 | use cpu::features::CpuFeatures;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `memory::paging::PageTableManager`
  --> kernel\src\arch\x86_64\mod.rs:48:5
   |
48 | use memory::paging::PageTableManager;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `acpi`
  --> kernel\src\boot\mod.rs:17:7
   |
17 | #[cfg(feature = "acpi")]
   |       ^^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `acpi` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
   = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `FrameAllocator`
  --> kernel\src\boot\mod.rs:13:27
   |
13 | use crate::memory::{self, FrameAllocator};
   |                           ^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
 --> kernel\src\boot\multiboot2.rs:6:5
  |
6 | use core::ptr::NonNull;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused imports: `PhysicalMemoryRegion` and `PhysicalMemoryType`
 --> kernel\src\boot\multiboot2.rs:8:21
  |
8 | use crate::memory::{PhysicalMemoryRegion, PhysicalMemoryType};
  |                     ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
 --> kernel\src\boot\phases.rs:6:5
  |
6 | use core::ptr::NonNull;
  |     ^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `acpi`
  --> kernel\src\boot\early_init.rs:56:7
   |
56 | #[cfg(feature = "acpi")]
   |       ^^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `acpi` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `ai`
  --> kernel\src\boot\late_init.rs:83:11
   |
83 |     #[cfg(feature = "ai")]
   |           ^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `ai` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `tpm`
  --> kernel\src\boot\late_init.rs:95:11
   |
95 |     #[cfg(feature = "tpm")]
   |           ^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `tpm` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `acpi`
   --> kernel\src\boot\recovery.rs:160:11
    |
160 |     #[cfg(feature = "acpi")]
    |           ^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
    = help: consider adding `acpi` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `acpi`
   --> kernel\src\boot\recovery.rs:187:11
    |
187 |     #[cfg(feature = "acpi")]
    |           ^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
    = help: consider adding `acpi` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `AtomicUsize` and `Ordering`
 --> kernel\src\memory\physical\mod.rs:9:26
  |
9 | use core::sync::atomic::{AtomicUsize, Ordering};
  |                          ^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\physical\bitmap_allocator.rs:8:21
  |
8 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\physical\bitmap_allocator.rs:9:5
  |
9 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\physical\buddy_allocator.rs:8:21
  |
8 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\physical\buddy_allocator.rs:9:5
  |
9 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
  --> kernel\src\memory\physical\zone.rs:11:5
   |
11 | use crate::arch;
   |     ^^^^^^^^^^^

warning: unused import: `AtomicUsize`
  --> kernel\src\memory\physical\zone.rs:12:26
   |
12 | use core::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
   |                          ^^^^^^^^^^^

warning: unused imports: `AtomicUsize` and `Ordering`
  --> kernel\src\memory\virtual_mem\page_table.rs:12:26
   |
12 | use core::sync::atomic::{AtomicUsize, Ordering};
   |                          ^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `PageProtection`
 --> kernel\src\memory\virtual_mem\cow.rs:7:81
  |
7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
  |                                                                                 ^^^^^^^^^^^^^^

warning: unused import: `page_table::PageTable`
   --> kernel\src\memory\virtual_mem\mod.rs:209:5
    |
209 | use page_table::PageTable;
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
  --> kernel\src\memory\heap\mod.rs:10:5
   |
10 | use crate::arch;
   |     ^^^^^^^^^^^

warning: unused import: `MemoryError`
 --> kernel\src\memory\heap\hybrid_allocator.rs:7:35
  |
7 | use crate::memory::{MemoryResult, MemoryError};
  |                                   ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\hybrid_allocator.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\thread_cache.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\cpu_slab.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\heap\slab.rs:6:48
  |
6 | use crate::memory::{MemoryResult, MemoryError, PhysicalAddress, VirtualAddress, phys_to_virt};
  |                                                ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\slab.rs:7:5
  |
7 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\shared\mod.rs:7:21
  |
7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\shared\pool.rs:6:21
  |
6 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\shared\pool.rs:7:5
  |
7 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\cache.rs:6:21
  |
6 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused imports: `AllocationOptions` and `PhysicalAddress`
 --> kernel\src\memory\dma.rs:6:37
  |
6 | use crate::memory::{VirtualAddress, PhysicalAddress, MemoryResult, MemoryError, AllocationOptions};
  |                                     ^^^^^^^^^^^^^^^                             ^^^^^^^^^^^^^^^^^

warning: unused imports: `AllocationOptions` and `PhysicalAddress`
 --> kernel\src\memory\mmap.rs:6:37
  |
6 | use crate::memory::{VirtualAddress, PhysicalAddress, MemoryResult, MemoryError, AllocationOptions};
  |                                     ^^^^^^^^^^^^^^^                             ^^^^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
  --> kernel\src\memory\mod.rs:73:5
   |
73 | use core::ptr::NonNull;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `spin::Mutex`
  --> kernel\src\drivers\mod.rs:18:5
   |
18 | use spin::Mutex; // Utiliser `spin` pour les mutexes dans un environnement noyau
   |     ^^^^^^^^^^^

error[E0107]: missing generics for trait `FrameAllocator`
  --> kernel\src\arch\x86_64\memory\numa.rs:29:47
   |
29 |     pub frame_allocator: Mutex<Option<Box<dyn FrameAllocator>>>,
   |                                               ^^^^^^^^^^^^^^ expected 1 generic argument
   |
note: trait defined here, with 1 generic parameter: `S`
  --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\x86_64-0.14.13\src\structures\paging\frame_alloc.rs:12:18
   |
12 | pub unsafe trait FrameAllocator<S: PageSize> {
   |                  ^^^^^^^^^^^^^^ -
help: add missing generic argument
   |
29 |     pub frame_allocator: Mutex<Option<Box<dyn FrameAllocator<S>>>>,
   |                                                             +++

error[E0277]: the trait bound `CacheType: Default` is not satisfied
  --> kernel\src\arch\x86_64\cpu\cpuid.rs:45:5
   |
42 | #[derive(Debug, Clone, Copy, Default)]
   |                              ------- in this derive macro expansion
...
45 |     pub cache_type: CacheType,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
   |
help: the trait `Default` is not implemented for `CacheType`
  --> kernel\src\arch\x86_64\cpu\cpuid.rs:35:1
   |
35 | pub enum CacheType {
   | ^^^^^^^^^^^^^^^^^^

error: cannot use register `bx`: rbx is used internally by LLVM and cannot be used as an operand for inline asm
   --> kernel\src\arch\x86_64\cpu\cpuid.rs:136:9
    |
136 |         out("ebx") ebx,
    |         ^^^^^^^^^^^^^^

error: cannot use register `bx`: rbx is used internally by LLVM and cannot be used as an operand for inline asm
   --> kernel\src\arch\x86_64\cpu\cpuid.rs:154:9
    |
154 |         out("ebx") ebx,
    |         ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\cpu\features.rs:68:20
    |
 68 |         cr4.insert(Cr4Flags::SUPERVISOR_MODE_EXECUTION_PROTECTION);
    |             ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `arch::x86_64::registers::Cr4Flags`, found `x86_64::registers::control::Cr4Flags`
    |             |
    |             arguments to this method are incorrect
    |
    = note: `x86_64::registers::control::Cr4Flags` and `arch::x86_64::registers::Cr4Flags` have similar names, but are actually distinct types
note: `x86_64::registers::control::Cr4Flags` is defined in crate `x86_64`
   --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\x86_64-0.14.13\src\registers\control.rs:98:1
    |
 98 | / bitflags! {
 99 | |     /// Configuration flags of the [`Cr4`] register.
100 | |     #[repr(transparent)]
101 | |     #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
...   |
179 | | }
    | |_^
note: `arch::x86_64::registers::Cr4Flags` is defined in the current crate
   --> kernel\src\arch\x86_64\registers.rs:71:1
    |
 71 | / bitflags! {
 72 | |     pub struct Cr4Flags: u64 {
 73 | |         const VME = 1 << 0;    // Virtual-8086 Mode Extensions
 74 | |         const PVI = 1 << 1;    // Protected-Mode Virtual Interrupts
...   |
 93 | | }
    | |_^
note: method defined here
   --> kernel\src\arch\x86_64\registers.rs:71:1
    |
 71 | / bitflags! {
 72 | |     pub struct Cr4Flags: u64 {
 73 | |         const VME = 1 << 0;    // Virtual-8086 Mode Extensions
 74 | |         const PVI = 1 << 1;    // Protected-Mode Virtual Interrupts
...   |
 93 | | }
    | |_^
    = note: this error originates in the macro `$crate::__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\cpu\features.rs:70:20
    |
 70 |         cr4.insert(Cr4Flags::SUPERVISOR_MODE_ACCESS_PREVENTION);
    |             ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `arch::x86_64::registers::Cr4Flags`, found `x86_64::registers::control::Cr4Flags`
    |             |
    |             arguments to this method are incorrect
    |
    = note: `x86_64::registers::control::Cr4Flags` and `arch::x86_64::registers::Cr4Flags` have similar names, but are actually distinct types
note: `x86_64::registers::control::Cr4Flags` is defined in crate `x86_64`
   --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\x86_64-0.14.13\src\registers\control.rs:98:1
    |
 98 | / bitflags! {
 99 | |     /// Configuration flags of the [`Cr4`] register.
100 | |     #[repr(transparent)]
101 | |     #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
...   |
179 | | }
    | |_^
note: `arch::x86_64::registers::Cr4Flags` is defined in the current crate
   --> kernel\src\arch\x86_64\registers.rs:71:1
    |
 71 | / bitflags! {
 72 | |     pub struct Cr4Flags: u64 {
 73 | |         const VME = 1 << 0;    // Virtual-8086 Mode Extensions
 74 | |         const PVI = 1 << 1;    // Protected-Mode Virtual Interrupts
...   |
 93 | | }
    | |_^
note: method defined here
   --> kernel\src\arch\x86_64\registers.rs:71:1
    |
 71 | / bitflags! {
 72 | |     pub struct Cr4Flags: u64 {
 73 | |         const VME = 1 << 0;    // Virtual-8086 Mode Extensions
 74 | |         const PVI = 1 << 1;    // Protected-Mode Virtual Interrupts
...   |
 93 | | }
    | |_^
    = note: this error originates in the macro `$crate::__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\cpu\features.rs:82:21
    |
 82 |         efer.insert(EferFlags::NO_EXECUTE_ENABLE);
    |              ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `arch::x86_64::registers::EferFlags`, found `x86_64::registers::control::EferFlags`
    |              |
    |              arguments to this method are incorrect
    |
    = note: `x86_64::registers::control::EferFlags` and `arch::x86_64::registers::EferFlags` have similar names, but are actually distinct types
note: `x86_64::registers::control::EferFlags` is defined in crate `x86_64`
   --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\x86_64-0.14.13\src\registers\model_specific.rs:111:1
    |
111 | / bitflags! {
112 | |     /// Flags of the Extended Feature Enable Register.
113 | |     #[repr(transparent)]
114 | |     #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
...   |
133 | | }
    | |_^
note: `arch::x86_64::registers::EferFlags` is defined in the current crate
   --> kernel\src\arch\x86_64\registers.rs:308:1
    |
308 | / bitflags! {
309 | |     pub struct EferFlags: u64 {
310 | |         const SCE = 1 << 0;   // System Call Extensions
311 | |         const LME = 1 << 8;   // Long Mode Enable
...   |
319 | | }
    | |_^
note: method defined here
   --> kernel\src\arch\x86_64\registers.rs:308:1
    |
308 | / bitflags! {
309 | |     pub struct EferFlags: u64 {
310 | |         const SCE = 1 << 0;   // System Call Extensions
311 | |         const LME = 1 << 8;   // Long Mode Enable
...   |
319 | | }
    | |_^
    = note: this error originates in the macro `$crate::__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no associated item named `PCID_ENABLE` found for struct `x86_64::registers::control::Cr4Flags` in the current scope
  --> kernel\src\arch\x86_64\cpu\features.rs:95:30
   |
95 |         cr4.insert(Cr4Flags::PCID_ENABLE);
   |                              ^^^^^^^^^^^ associated item not found in `x86_64::registers::control::Cr4Flags`

warning: formatting may not be suitable for sub-register argument
   --> kernel\src\arch\x86_64\cpu\topology.rs:180:23
    |
180 |             "mov ecx, {level}",
    |                       ^^^^^^^
181 |             "cpuid",
182 |             level = in(reg) level,
    |                             ----- for this argument
    |
    = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)
    = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)
    = note: `#[warn(asm_sub_register)]` on by default

error: cannot use register `bx`: rbx is used internally by LLVM and cannot be used as an operand for inline asm
   --> kernel\src\arch\x86_64\cpu\topology.rs:184:13
    |
184 |             lateout("ebx") _,
    |             ^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\memory\paging.rs:213:52
    |
213 |         let msr = super::super::cpu::msr::read_msr(0xC0000080); // EFER MSR
    |                   -------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |                   |
    |                   arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:375:15
    |
375 | pub unsafe fn read_msr(msr: Msr) -> MsrValue {
    |               ^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\memory\paging.rs:217:47
    |
217 |             super::super::cpu::msr::write_msr(0xC0000080, super::super::cpu::msr::MsrValue::new(efer));
    |             --------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |             |
    |             arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

warning: formatting may not be suitable for sub-register argument
  --> kernel\src\arch\x86_64\memory\tlb.rs:98:26
   |
98 |                 "invpcid {0}, [{1}]",
   |                          ^^^
99 |                 in(reg) 1, // Single context invalidation
   |                         - for this argument
   |
   = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)
   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\memory\pat.rs:51:46
    |
 51 |         let pat_msr = unsafe { msr::read_msr(0x277) }; // IA32_PAT MSR
    |                                ------------- ^^^^^ expected `Msr`, found integer
    |                                |
    |                                arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:375:15
    |
375 | pub unsafe fn read_msr(msr: Msr) -> MsrValue {
    |               ^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\memory\pat.rs:134:28
    |
134 |             msr::write_msr(0x277, msr::MsrValue::new(self.current_value));
    |             -------------- ^^^^^ expected `Msr`, found integer
    |             |
    |             arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

error[E0308]: arguments to this method are incorrect
  --> kernel\src\arch\x86_64\memory\numa.rs:62:23
   |
62 |             allocator.add_range(range.base, range.base + range.size);
   |                       ^^^^^^^^^ ----------  ----------------------- expected `PhysAddr`, found `usize`
   |                                 |
   |                                 expected `PhysAddr`, found `usize`
   |
note: method defined here
  --> kernel\src\memory\frame_allocator.rs:32:12
   |
32 |     pub fn add_range(&mut self, start: PhysAddr, end: PhysAddr) {
   |            ^^^^^^^^^            ---------------  -------------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\memory\mod.rs:111:32
    |
111 |     let heap = LockedHeap::new(heap_start, heap_size);
    |                --------------- ^^^^^^^^^^ expected `*mut u8`, found `usize`
    |                |
    |                arguments to this function are incorrect
    |
    = note: expected raw pointer `*mut u8`
                      found type `usize`
note: associated function defined here
   --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\linked_list_allocator-0.10.5\src\lib.rs:315:19
    |
315 |     pub unsafe fn new(heap_bottom: *mut u8, heap_size: usize) -> LockedHeap {
    |                   ^^^

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:210:25
    |
210 |     if let Some(task) = scheduler::current_task() {
    |                         ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0282]: type annotations needed
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:211:42
    |
211 |         error!("Faulting task: {}", task.name());
    |                                          ^^^^ cannot infer type

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:254:25
    |
254 |     if let Some(task) = scheduler::current_task() {
    |                         ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0282]: type annotations needed
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:255:42
    |
255 |         error!("Faulting task: {}", task.name());
    |                                          ^^^^ cannot infer type

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:312:5
    |
312 |     scheduler::handle_timer_tick();
    |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:362:5
    |
362 |     scheduler::trigger_reschedule();
    |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0599]: no associated item named `UNCACHED` found for struct `PageFlags` in the current scope
   --> kernel\src\arch\x86_64\interrupts\apic.rs:102:57
    |
102 |           alloc_pages(1, PageFlags::WRITABLE | PageFlags::UNCACHED)
    |                                                           ^^^^^^^^ associated item not found in `PageFlags`
    |
   ::: kernel\src\arch\x86_64\memory\mod.rs:43:1
    |
 43 | / bitflags::bitflags! {
 44 | |     pub struct PageFlags: u64 {
 45 | |         const PRESENT = 1 << 0;
 46 | |         const WRITABLE = 1 << 1;
...   |
 56 | | }
    | |_- associated item `UNCACHED` not found for this struct

error[E0061]: this function takes 0 arguments but 2 arguments were supplied
   --> kernel\src\arch\x86_64\interrupts\apic.rs:102:9
    |
102 |         alloc_pages(1, PageFlags::WRITABLE | PageFlags::UNCACHED)
    |         ^^^^^^^^^^^ -  ----------------------------------------- unexpected argument #2 of type `PageFlags`
    |                     |
    |                     unexpected argument #1 of type `{integer}`
    |
note: function defined here
   --> kernel\src\memory\physical\mod.rs:317:8
    |
317 | pub fn allocate_frame() -> MemoryResult<Frame> {
    |        ^^^^^^^^^^^^^^
help: remove the extra arguments
    |
102 -         alloc_pages(1, PageFlags::WRITABLE | PageFlags::UNCACHED)
102 +         alloc_pages()
    |

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\interrupts\apic.rs:103:35
    |
103 |             .map(|p| phys_to_virt(p))?
    |                      ------------ ^ expected `PhysicalAddress`, found `Frame`
    |                      |
    |                      arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\memory\mod.rs:62:8
    |
 62 | pub fn phys_to_virt(phys: PhysicalAddress) -> VirtualAddress {
    |        ^^^^^^^^^^^^ ---------------------

error[E0277]: `?` couldn't convert the error to `()`
   --> kernel\src\arch\x86_64\interrupts\apic.rs:103:38
    |
 85 | pub fn init() -> Result<(), ()> {
    |                  -------------- expected `()` because of this
...
102 |         alloc_pages(1, PageFlags::WRITABLE | PageFlags::UNCACHED)
    |         --------------------------------------------------------- this can't be annotated with `?` because it has type `Result<_, MemoryError>`
103 |             .map(|p| phys_to_virt(p))?
    |                                      ^ the trait `From<MemoryError>` is not implemented for `()`
    |
note: `MemoryError` needs to implement `Into<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `(T, T)` implements `From<[T; 2]>`
              `(T, T, T)` implements `From<[T; 3]>`
              `(T, T, T, T)` implements `From<[T; 4]>`
              `(T, T, T, T, T)` implements `From<[T; 5]>`
              `(T, T, T, T, T, T)` implements `From<[T; 6]>`
              `(T, T, T, T, T, T, T)` implements `From<[T; 7]>`
              `(T, T, T, T, T, T, T, T)` implements `From<[T; 8]>`
              `(T, T, T, T, T, T, T, T, T)` implements `From<[T; 9]>`
            and 4 others

error[E0599]: no associated item named `UNCACHED` found for struct `PageFlags` in the current scope
   --> kernel\src\arch\x86_64\interrupts\apic.rs:112:46
    |
112 |               PageFlags::WRITABLE | PageFlags::UNCACHED,
    |                                                ^^^^^^^^ associated item not found in `PageFlags`
    |
   ::: kernel\src\arch\x86_64\memory\mod.rs:43:1
    |
 43 | / bitflags::bitflags! {
 44 | |     pub struct PageFlags: u64 {
 45 | |         const PRESENT = 1 << 0;
 46 | |         const WRITABLE = 1 << 1;
...   |
 56 | | }
    | |_- associated item `UNCACHED` not found for this struct

error[E0605]: non-primitive cast: `VirtualAddress` as `u64`
   --> kernel\src\arch\x86_64\interrupts\apic.rs:118:20
    |
118 |         base_virt: apic_virt as u64,
    |                    ^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> kernel\src\arch\x86_64\interrupts\apic.rs:150:23
    |
150 |         apic_base_msr.set_bit(11, true);
    |                       ^^^^^^^     ---- unexpected argument #2 of type `bool`
    |
note: method defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:178:12
    |
178 |     pub fn set_bit(&mut self, bit: u8) {
    |            ^^^^^^^
help: remove the extra argument
    |
150 -         apic_base_msr.set_bit(11, true);
150 +         apic_base_msr.set_bit(11);
    |

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> kernel\src\arch\x86_64\interrupts\apic.rs:301:15
    |
301 |     apic_base.set_bit(10, true); // x2APIC enable
    |               ^^^^^^^     ---- unexpected argument #2 of type `bool`
    |
note: method defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:178:12
    |
178 |     pub fn set_bit(&mut self, bit: u8) {
    |            ^^^^^^^
help: remove the extra argument
    |
301 -     apic_base.set_bit(10, true); // x2APIC enable
301 +     apic_base.set_bit(10); // x2APIC enable
    |

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> kernel\src\arch\x86_64\interrupts\apic.rs:302:15
    |
302 |     apic_base.set_bit(11, true); // APIC global enable
    |               ^^^^^^^     ---- unexpected argument #2 of type `bool`
    |
note: method defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:178:12
    |
178 |     pub fn set_bit(&mut self, bit: u8) {
    |            ^^^^^^^
help: remove the extra argument
    |
302 -     apic_base.set_bit(11, true); // APIC global enable
302 +     apic_base.set_bit(11); // APIC global enable
    |

error[E0599]: no associated item named `UNCACHED` found for struct `PageFlags` in the current scope
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:127:76
    |
127 |               crate::memory::PageFlags::WRITABLE | crate::memory::PageFlags::UNCACHED,
    |                                                                              ^^^^^^^^ associated item not found in `PageFlags`
    |
   ::: kernel\src\arch\x86_64\memory\mod.rs:43:1
    |
 43 | / bitflags::bitflags! {
 44 | |     pub struct PageFlags: u64 {
 45 | |         const PRESENT = 1 << 0;
 46 | |         const WRITABLE = 1 << 1;
...   |
 56 | | }
    | |_- associated item `UNCACHED` not found for this struct

error[E0277]: `?` couldn't convert the error to `ArchError`
  --> kernel\src\arch\x86_64\interrupts\mod.rs:23:17
   |
15 | pub fn init() -> Result<(), ArchError> {
   |                  --------------------- expected `ArchError` because of this
...
23 |     apic::init()?;
   |     ------------^ the trait `From<()>` is not implemented for `ArchError`
   |     |
   |     this can't be annotated with `?` because it has type `Result<_, ()>`
   |
note: `ArchError` needs to implement `From<()>`
  --> kernel\src\arch\mod.rs:83:1
   |
83 | pub enum ArchError {
   | ^^^^^^^^^^^^^^^^^^
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0787]: the `asm!` macro is not allowed in naked functions
  --> kernel\src\arch\x86_64\context.rs:73:9
   |
73 | /         asm!(
74 | |             // Save old context
75 | |             "mov [rdi], rsp",    // Save RSP
76 | |             "mov [rdi + 8], rbp", // Save RBP
...  |
94 | |             options(noreturn)
95 | |         )
   | |_________^ consider using the `naked_asm!` macro instead

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\syscall.rs:42:65
    |
 42 |         let msr_value = crate::arch::x86_64::cpu::msr::read_msr(0xC0000080); // EFER MSR
    |                         --------------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |                         |
    |                         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:375:15
    |
375 | pub unsafe fn read_msr(msr: Msr) -> MsrValue {
    |               ^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\syscall.rs:46:50
    |
 46 |         crate::arch::x86_64::cpu::msr::write_msr(0xC0000080, crate::arch::x86_64::cpu::msr::MsrValue::new(efer));
    |         ---------------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\syscall.rs:52:50
    |
 52 |         crate::arch::x86_64::cpu::msr::write_msr(0xC0000081, crate::arch::x86_64::cpu::msr::MsrValue::new(star_value));
    |         ---------------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\syscall.rs:56:50
    |
 56 |         crate::arch::x86_64::cpu::msr::write_msr(0xC0000082, crate::arch::x86_64::cpu::msr::MsrValue::new(lstar_value));
    |         ---------------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

error[E0308]: mismatched types
   --> kernel\src\arch\x86_64\syscall.rs:60:50
    |
 60 |         crate::arch::x86_64::cpu::msr::write_msr(0xC0000084, crate::arch::x86_64::cpu::msr::MsrValue::new(fmask_value));
    |         ---------------------------------------- ^^^^^^^^^^ expected `Msr`, found integer
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:380:15
    |
380 | pub unsafe fn write_msr(msr: Msr, value: MsrValue) {
    |               ^^^^^^^^^ --------

error[E0787]: the `asm!` macro is not allowed in naked functions
   --> kernel\src\arch\x86_64\syscall.rs:102:9
    |
102 | /         asm!(
103 | |             // Save user state
104 | |             "swapgs",                           // Switch to kernel GS base
105 | |             "mov gs:[0], rsp",                  // Save user RSP
...   |
133 | |             options(noreturn)
134 | |         )
    | |_________^ consider using the `naked_asm!` macro instead

error[E0599]: no method named `to_string` found for reference `&str` in the current scope
   --> kernel\src\boot\multiboot2.rs:154:18
    |
151 | /             core::ffi::CStr::from_ptr(name_ptr as *const i8)
152 | |                 .to_str()
153 | |                 .unwrap_or("unknown")
154 | |                 .to_string()
    | |                 -^^^^^^^^^ method not found in `&str`
    | |_________________|
    |
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it
    |
  6 + use crate::alloc::string::ToString;
    |

error[E0599]: no method named `to_string` found for reference `&'static str` in the current scope
   --> kernel\src\boot\multiboot2.rs:156:23
    |
156 |             "unknown".to_string()
    |                       ^^^^^^^^^ method not found in `&'static str`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it
    |
  6 + use crate::alloc::string::ToString;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
  --> kernel\src\boot\late_init.rs:14:5
   |
14 |     scheduler::init();
   |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
   |
   = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `ipc`
  --> kernel\src\boot\late_init.rs:21:5
   |
21 |     ipc::init();
   |     ^^^ use of unresolved module or unlinked crate `ipc`
   |
   = help: if you wanted to use a crate named `ipc`, use `cargo add ipc` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:29:5
   |
29 |     drivers::init();
   |     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:32:21
   |
32 |     if let Err(e) = drivers::probe_all() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `ipc`
   --> kernel\src\boot\late_init.rs:115:5
    |
115 |     ipc::start_service();
    |     ^^^ use of unresolved module or unlinked crate `ipc`
    |
    = help: if you wanted to use a crate named `ipc`, use `cargo add ipc` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
   --> kernel\src\boot\late_init.rs:118:5
    |
118 |     drivers::start_service_manager();
    |     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
    |
    = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0609]: no field `family` on type `CpuIdInfo`
   --> kernel\src\boot\recovery.rs:224:20
    |
224 |              cpuid.family, cpuid.model, cpuid.stepping).ok();
    |                    ^^^^^^ unknown field
    |
    = note: available fields are: `vendor`, `max_leaf`

error[E0609]: no field `model` on type `CpuIdInfo`
   --> kernel\src\boot\recovery.rs:224:34
    |
224 |              cpuid.family, cpuid.model, cpuid.stepping).ok();
    |                                  ^^^^^ unknown field
    |
    = note: available fields are: `vendor`, `max_leaf`

error[E0609]: no field `stepping` on type `CpuIdInfo`
   --> kernel\src\boot\recovery.rs:224:47
    |
224 |              cpuid.family, cpuid.model, cpuid.stepping).ok();
    |                                               ^^^^^^^^ unknown field
    |
    = note: available fields are: `vendor`, `max_leaf`

warning: unreachable statement
   --> kernel\src\boot\mod.rs:125:5
    |
122 |     recovery::recovery_shell();
    |     -------------------------- any code following this expression is unreachable
...
125 |     crate::arch::halt();
    |     ^^^^^^^^^^^^^^^^^^^^ unreachable statement
    |
    = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0308]: mismatched types
  --> kernel\src\memory\physical\mod.rs:91:30
   |
91 |         if address.value() < crate::arch::dma::DMA_MAX_ADDRESS {
   |            ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
   |            |
   |            expected because this is `usize`
   |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
   |
91 |         if address.value() < crate::arch::dma::DMA_MAX_ADDRESS.try_into().unwrap() {
   |                                                               ++++++++++++++++++++

error[E0308]: mismatched types
  --> kernel\src\memory\physical\mod.rs:93:37
   |
93 |         } else if address.value() < crate::arch::HIGH_MEMORY_START {
   |                   ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
   |                   |
   |                   expected because this is `usize`
   |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
   |
93 |         } else if address.value() < crate::arch::HIGH_MEMORY_START.try_into().unwrap() {
   |                                                                   ++++++++++++++++++++

error[E0599]: no method named `zones` found for reference `&ZoneManager` in the current scope
   --> kernel\src\memory\physical\bitmap_allocator.rs:97:38
    |
 97 |             for zone in zone_manager.zones() {
    |                                      ^^^^^
    |
help: there is a method `zone_stats` with a similar name, but with different arguments
   --> kernel\src\memory\physical\zone.rs:309:5
    |
309 |     pub fn zone_stats(&self, zone: MemoryZone) -> &ZoneStats {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:109:76
    |
109 |             let kernel_start = crate::arch::KERNEL_START_ADDRESS.value() / FRAME_SIZE;
    |                                                                            ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot divide `u64` by `usize`
   --> kernel\src\memory\physical\bitmap_allocator.rs:109:74
    |
109 |             let kernel_start = crate::arch::KERNEL_START_ADDRESS.value() / FRAME_SIZE;
    |                                                                          ^ no implementation for `u64 / usize`
    |
    = help: the trait `Div<usize>` is not implemented for `u64`
    = help: the following other types implement trait `Div<Rhs>`:
              `&u64` implements `Div<u64>`
              `&u64` implements `Div`
              `u64` implements `Div<&u64>`
              `u64` implements `Div<NonZero<u64>>`
              `u64` implements `Div<zerocopy::byteorder::U64<O>>`
              `u64` implements `Div`

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:110:72
    |
110 |             let kernel_end = crate::arch::KERNEL_END_ADDRESS.value() / FRAME_SIZE;
    |                                                                        ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot divide `u64` by `usize`
   --> kernel\src\memory\physical\bitmap_allocator.rs:110:70
    |
110 |             let kernel_end = crate::arch::KERNEL_END_ADDRESS.value() / FRAME_SIZE;
    |                                                                      ^ no implementation for `u64 / usize`
    |
    = help: the trait `Div<usize>` is not implemented for `u64`
    = help: the following other types implement trait `Div<Rhs>`:
              `&u64` implements `Div<u64>`
              `&u64` implements `Div`
              `u64` implements `Div<&u64>`
              `u64` implements `Div<NonZero<u64>>`
              `u64` implements `Div<zerocopy::byteorder::U64<O>>`
              `u64` implements `Div`

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:113:30
    |
113 |                 self.set_bit(frame_num);
    |                      ------- ^^^^^^^^^ expected `usize`, found `u64`
    |                      |
    |                      arguments to this method are incorrect
    |
note: method defined here
   --> kernel\src\memory\physical\bitmap_allocator.rs:228:8
    |
228 |     fn set_bit(&mut self, frame_num: usize) {
    |        ^^^^^^^            ----------------
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
113 |                 self.set_bit(frame_num.try_into().unwrap());
    |                                       ++++++++++++++++++++

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:276:72
    |
276 |         let kernel_start = crate::arch::KERNEL_START_ADDRESS.value() / FRAME_SIZE;
    |                                                                        ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot divide `u64` by `usize`
   --> kernel\src\memory\physical\bitmap_allocator.rs:276:70
    |
276 |         let kernel_start = crate::arch::KERNEL_START_ADDRESS.value() / FRAME_SIZE;
    |                                                                      ^ no implementation for `u64 / usize`
    |
    = help: the trait `Div<usize>` is not implemented for `u64`
    = help: the following other types implement trait `Div<Rhs>`:
              `&u64` implements `Div<u64>`
              `&u64` implements `Div`
              `u64` implements `Div<&u64>`
              `u64` implements `Div<NonZero<u64>>`
              `u64` implements `Div<zerocopy::byteorder::U64<O>>`
              `u64` implements `Div`

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:277:68
    |
277 |         let kernel_end = crate::arch::KERNEL_END_ADDRESS.value() / FRAME_SIZE;
    |                                                                    ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot divide `u64` by `usize`
   --> kernel\src\memory\physical\bitmap_allocator.rs:277:66
    |
277 |         let kernel_end = crate::arch::KERNEL_END_ADDRESS.value() / FRAME_SIZE;
    |                                                                  ^ no implementation for `u64 / usize`
    |
    = help: the trait `Div<usize>` is not implemented for `u64`
    = help: the following other types implement trait `Div<Rhs>`:
              `&u64` implements `Div<u64>`
              `&u64` implements `Div`
              `u64` implements `Div<&u64>`
              `u64` implements `Div<NonZero<u64>>`
              `u64` implements `Div<zerocopy::byteorder::U64<O>>`
              `u64` implements `Div`

error[E0308]: mismatched types
   --> kernel\src\memory\physical\bitmap_allocator.rs:279:9
    |
274 |     fn count_reserved_frames(&self) -> usize {
    |                                        ----- expected `usize` because of return type
...
279 |         kernel_end - kernel_start
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
    |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
279 |         (kernel_end - kernel_start).try_into().unwrap()
    |         +                         +++++++++++++++++++++

error[E0599]: no method named `zones` found for reference `&ZoneManager` in the current scope
   --> kernel\src\memory\physical\buddy_allocator.rs:107:34
    |
107 |         for zone in zone_manager.zones() {
    |                                  ^^^^^
    |
help: there is a method `zone_stats` with a similar name, but with different arguments
   --> kernel\src\memory\physical\zone.rs:309:5
    |
309 |     pub fn zone_stats(&self, zone: MemoryZone) -> &ZoneStats {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\physical\buddy_allocator.rs:375:62
    |
375 |         let kernel_start = crate::arch::KERNEL_START_ADDRESS.value() / FRAME_SIZE;
    |                                                              ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\physical\buddy_allocator.rs:376:58
    |
376 |         let kernel_end = crate::arch::KERNEL_END_ADDRESS.value() / FRAME_SIZE;
    |                                                          ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0308]: mismatched types
  --> kernel\src\memory\physical\zone.rs:46:30
   |
46 |         if address.value() < crate::arch::dma::DMA_MAX_ADDRESS {
   |            ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
   |            |
   |            expected because this is `usize`
   |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
   |
46 |         if address.value() < crate::arch::dma::DMA_MAX_ADDRESS.try_into().unwrap() {
   |                                                               ++++++++++++++++++++

error[E0308]: mismatched types
  --> kernel\src\memory\physical\zone.rs:48:37
   |
48 |         } else if address.value() < crate::arch::HIGH_MEMORY_START {
   |                   ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
   |                   |
   |                   expected because this is `usize`
   |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
   |
48 |         } else if address.value() < crate::arch::HIGH_MEMORY_START.try_into().unwrap() {
   |                                                                   ++++++++++++++++++++

error[E0282]: type annotations needed
   --> kernel\src\memory\physical\numa.rs:194:45
    |
194 |                 node.add_memory_range(range.clone());
    |                                             ^^^^^ cannot infer type

error[E0308]: mismatched types
   --> kernel\src\memory\physical\numa.rs:263:33
    |
263 |         self.local_node_for_cpu(current_cpu)
    |              ------------------ ^^^^^^^^^^^ expected `u32`, found `usize`
    |              |
    |              arguments to this method are incorrect
    |
note: method defined here
   --> kernel\src\memory\physical\numa.rs:251:12
    |
251 |     pub fn local_node_for_cpu(&self, cpu_id: u32) -> Option<u32> {
    |            ^^^^^^^^^^^^^^^^^^        -----------
help: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit
    |
263 |         self.local_node_for_cpu(current_cpu.try_into().unwrap())
    |                                            ++++++++++++++++++++

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\virtual_mem\page_table.rs:88:72
    |
 88 |         let virtual_address = arch::mmu::map_temporary(frame.address())?;
    |                               -----------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                               |
    |                               this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0599]: no method named `value` found for type `usize` in the current scope
  --> kernel\src\memory\virtual_mem\page_table.rs:92:52
   |
92 |             core::ptr::write_bytes(virtual_address.value() as *mut u8, 0, arch::PAGE_SIZE);
   |                                                    ^^^^^ method not found in `usize`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
note: `U64Value` defines an item `value`, perhaps you need to implement it
  --> kernel\src\memory\physical\bitmap_allocator.rs:13:1
   |
13 | trait U64Value {
   | ^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> kernel\src\memory\virtual_mem\page_table.rs:97:13
   |
97 |             virtual_address,
   |             ^^^^^^^^^^^^^^^ expected `VirtualAddress`, found `usize`
   |
help: try wrapping the expression in `memory::VirtualAddress`
   |
97 |             virtual_address: memory::VirtualAddress(virtual_address),
   |             ++++++++++++++++++++++++++++++++++++++++               +

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\virtual_mem\page_table.rs:105:73
    |
105 |         let virtual_address = arch::mmu::map_temporary(physical_address)?;
    |                               ------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                               |
    |                               this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\page_table.rs:109:13
    |
109 |             virtual_address,
    |             ^^^^^^^^^^^^^^^ expected `VirtualAddress`, found `usize`
    |
help: try wrapping the expression in `memory::VirtualAddress`
    |
109 |             virtual_address: memory::VirtualAddress(virtual_address),
    |             ++++++++++++++++++++++++++++++++++++++++               +

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\page_table.rs:159:44
    |
159 |         let _ = arch::mmu::unmap_temporary(self.virtual_address);
    |                 -------------------------- ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `VirtualAddress`
    |                 |
    |                 arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:218:12
    |
218 |     pub fn unmap_temporary(_virtual_addr: usize) -> Result<(), ()> {
    |            ^^^^^^^^^^^^^^^ --------------------

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:358:34
    |
358 |     let kernel_size = kernel_end.value() - kernel_start.value();
    |                                  ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:358:57
    |
358 |     let kernel_size = kernel_end.value() - kernel_start.value();
    |                                                         ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:364:61
    |
364 |         let virtual_addr = VirtualAddress::new(kernel_start.value() + offset);
    |                                                             ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\page_table.rs:365:73
    |
365 |         let physical_addr = PhysicalAddress::new(virtual_addr.value() - crate::arch::KERNEL_VIRTUAL_OFFSET);
    |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot subtract `u64` from `usize`
   --> kernel\src\memory\virtual_mem\page_table.rs:365:71
    |
365 |         let physical_addr = PhysicalAddress::new(virtual_addr.value() - crate::arch::KERNEL_VIRTUAL_OFFSET);
    |                                                                       ^ no implementation for `usize - u64`
    |
    = help: the trait `Sub<u64>` is not implemented for `usize`
    = help: the following other types implement trait `Sub<Rhs>`:
              `&usize` implements `Sub<usize>`
              `&usize` implements `Sub`
              `usize` implements `Sub<&usize>`
              `usize` implements `Sub<zerocopy::byteorder::Usize<O>>`
              `usize` implements `Sub`

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:374:67
    |
374 |         if virtual_addr.value() >= crate::arch::KERNEL_CODE_START.value()
    |                                                                   ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:375:68
    |
375 |             && virtual_addr.value() < crate::arch::KERNEL_CODE_END.value() {
    |                                                                    ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `execute` found for struct `virtual_mem::PageTableFlags` in the current scope
   --> kernel\src\memory\virtual_mem\page_table.rs:380:18
    |
376 |               let flags = PageTableFlags::new()
    |  _________________________-
377 | |                 .present()
378 | |                 .writable()
379 | |                 .global()
380 | |                 .execute();
    | |_________________-^^^^^^^
    |
   ::: kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 |   pub struct PageTableFlags(u64);
    |   ------------------------- method `execute` not found for this struct
    |
help: there is a method `no_execute` with a similar name
    |
380 |                 .no_execute();
    |                  +++

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\virtual_mem\page_table.rs:387:60
    |
351 | pub fn init() -> MemoryResult<()> {
    |                  ---------------- expected `MemoryError` because of this
...
387 |     arch::mmu::enable_paging(root_table.physical_address())?;
    |     -------------------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |     |
    |     this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\mapper.rs:95:35
    |
 95 |         arch::mmu::invalidate_tlb(virtual_addr);
    |         ------------------------- ^^^^^^^^^^^^ expected `usize`, found `VirtualAddress`
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:185:12
    |
185 |     pub fn invalidate_tlb(_virtual_addr: usize) {
    |            ^^^^^^^^^^^^^^ --------------------

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\mapper.rs:114:35
    |
114 |         arch::mmu::invalidate_tlb(virtual_addr);
    |         ------------------------- ^^^^^^^^^^^^ expected `usize`, found `VirtualAddress`
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:185:12
    |
185 |     pub fn invalidate_tlb(_virtual_addr: usize) {
    |            ^^^^^^^^^^^^^^ --------------------

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\mapper.rs:137:35
    |
137 |         arch::mmu::invalidate_tlb(virtual_addr);
    |         ------------------------- ^^^^^^^^^^^^ expected `usize`, found `VirtualAddress`
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:185:12
    |
185 |     pub fn invalidate_tlb(_virtual_addr: usize) {
    |            ^^^^^^^^^^^^^^ --------------------

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:183:38
    |
183 |         let kernel_size = kernel_end.value() - kernel_start.value();
    |                                      ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:183:61
    |
183 |         let kernel_size = kernel_end.value() - kernel_start.value();
    |                                                             ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:189:65
    |
189 |             let virtual_addr = VirtualAddress::new(kernel_start.value() + offset);
    |                                                                 ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\address_space.rs:190:77
    |
190 |             let physical_addr = PhysicalAddress::new(virtual_addr.value() - crate::arch::KERNEL_VIRTUAL_OFFSET);
    |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot subtract `u64` from `usize`
   --> kernel\src\memory\virtual_mem\address_space.rs:190:75
    |
190 |             let physical_addr = PhysicalAddress::new(virtual_addr.value() - crate::arch::KERNEL_VIRTUAL_OFFSET);
    |                                                                           ^ no implementation for `usize - u64`
    |
    = help: the trait `Sub<u64>` is not implemented for `usize`
    = help: the following other types implement trait `Sub<Rhs>`:
              `&usize` implements `Sub<usize>`
              `&usize` implements `Sub`
              `usize` implements `Sub<&usize>`
              `usize` implements `Sub<zerocopy::byteorder::Usize<O>>`
              `usize` implements `Sub`

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:199:71
    |
199 |             if virtual_addr.value() >= crate::arch::KERNEL_CODE_START.value()
    |                                                                       ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `value` found for type `u64` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:200:72
    |
200 |                 && virtual_addr.value() < crate::arch::KERNEL_CODE_END.value() {
    |                                                                        ^^^^^ method not found in `u64`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = help: trait `crate::memory::physical::bitmap_allocator::U64Value` which provides `value` is implemented but not reachable

error[E0599]: no method named `execute` found for struct `virtual_mem::PageTableFlags` in the current scope
   --> kernel\src\memory\virtual_mem\address_space.rs:205:22
    |
201 |                   let flags = super::page_table::PageTableFlags::new()
    |  _____________________________-
202 | |                     .present()
203 | |                     .writable()
204 | |                     .global()
205 | |                     .execute();
    | |_____________________-^^^^^^^
    |
   ::: kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 |   pub struct PageTableFlags(u64);
    |   ------------------------- method `execute` not found for this struct
    |
help: there is a method `no_execute` with a similar name
    |
205 |                     .no_execute();
    |                      +++

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\address_space.rs:213:13
    |
212 |         let kernel_region = MemoryRegion::new(
    |                             ----------------- arguments to this function are incorrect
213 |             kernel_start,
    |             ^^^^^^^^^^^^ expected `VirtualAddress`, found `u64`
    |
note: associated function defined here
   --> kernel\src\memory\virtual_mem\address_space.rs:79:12
    |
 79 |     pub fn new(
    |            ^^^
 80 |         start: VirtualAddress,
    |         ---------------------

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\address_space.rs:293:44
    |
293 |         let user_end = VirtualAddress::new(crate::arch::KERNEL_BASE);
    |                        ------------------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> kernel\src\memory\mod.rs:113:18
    |
113 |     pub const fn new(addr: usize) -> Self {
    |                  ^^^ -----------
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
293 |         let user_end = VirtualAddress::new(crate::arch::KERNEL_BASE.try_into().unwrap());
    |                                                                    ++++++++++++++++++++

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\virtual_mem\cow.rs:176:66
    |
176 |         let temp_virtual = arch::mmu::map_temporary(new_physical)?;
    |                            --------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                            |
    |                            this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\virtual_mem\cow.rs:179:69
    |
179 |         let old_virtual = arch::mmu::map_temporary(current_physical)?;
    |                           ------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                           |
    |                           this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0599]: no method named `value` found for type `usize` in the current scope
   --> kernel\src\memory\virtual_mem\cow.rs:183:29
    |
183 |                 old_virtual.value() as *const u8,
    |                             ^^^^^ method not found in `usize`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `U64Value` defines an item `value`, perhaps you need to implement it
   --> kernel\src\memory\physical\bitmap_allocator.rs:13:1
    |
 13 | trait U64Value {
    | ^^^^^^^^^^^^^^

error[E0599]: no method named `value` found for type `usize` in the current scope
   --> kernel\src\memory\virtual_mem\cow.rs:184:30
    |
184 |                 temp_virtual.value() as *mut u8,
    |                              ^^^^^ method not found in `usize`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `U64Value` defines an item `value`, perhaps you need to implement it
   --> kernel\src\memory\physical\bitmap_allocator.rs:13:1
    |
 13 | trait U64Value {
    | ^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> kernel\src\memory\virtual_mem\mod.rs:358:31
    |
358 |     arch::mmu::invalidate_tlb(virtual_addr);
    |     ------------------------- ^^^^^^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:185:12
    |
185 |     pub fn invalidate_tlb(_virtual_addr: usize) {
    |            ^^^^^^^^^^^^^^ --------------------

error[E0609]: no field `allocation_count` on type `*mut SlabPage`
   --> kernel\src\memory\heap\slab.rs:210:17
    |
210 |         if page.allocation_count == 0 {
    |                 ^^^^^^^^^^^^^^^^ unknown field
    |
help: `page` is a raw pointer; try dereferencing it
    |
210 |         if (*page).allocation_count == 0 {
    |            ++    +

error[E0609]: no field `l1_instruction` on type `arch::cache::CacheInfo`
   --> kernel\src\memory\cache.rs:107:19
    |
107 |     if cache_info.l1_instruction.is_none() || cache_info.l1_data.is_none() {
    |                   ^^^^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `line_size`, `l1_size`, `l2_size`, `l3_size`

error[E0609]: no field `l1_data` on type `arch::cache::CacheInfo`
   --> kernel\src\memory\cache.rs:107:58
    |
107 |     if cache_info.l1_instruction.is_none() || cache_info.l1_data.is_none() {
    |                                                          ^^^^^^^ unknown field
    |
    = note: available fields are: `line_size`, `l1_size`, `l2_size`, `l3_size`

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:126:40
    |
126 |     arch::cache::invalidate_cache_line(address);
    |     ---------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:141:12
    |
141 |     pub fn invalidate_cache_line(_address: usize) {}
    |            ^^^^^^^^^^^^^^^^^^^^^ ---------------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:136:35
    |
136 |     arch::cache::clean_cache_line(address);
    |     ----------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:142:12
    |
142 |     pub fn clean_cache_line(_address: usize) {}
    |            ^^^^^^^^^^^^^^^^ ---------------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:146:50
    |
146 |     arch::cache::clean_and_invalidate_cache_line(address);
    |     -------------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:143:12
    |
143 |     pub fn clean_and_invalidate_cache_line(_address: usize) {}
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:152:39
    |
152 |     arch::cache::invalidate_cache_all(level);
    |     --------------------------------- ^^^^^ expected `u8`, found `CacheLevel`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:144:12
    |
144 |     pub fn invalidate_cache_all(_level: u8) {}
    |            ^^^^^^^^^^^^^^^^^^^^ ----------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:158:32
    |
158 |     arch::cache::prefetch_data(address);
    |     -------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:145:12
    |
145 |     pub fn prefetch_data(_address: usize) {}
    |            ^^^^^^^^^^^^^ ---------------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:164:39
    |
164 |     arch::cache::prefetch_instruction(address);
    |     --------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |     |
    |     arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:146:12
    |
146 |     pub fn prefetch_instruction(_address: usize) {}
    |            ^^^^^^^^^^^^^^^^^^^^ ---------------

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:209:13
    |
189 | pub fn optimize_data_layout<T>(data: &mut [T]) -> MemoryResult<()>
    |                             - expected this type parameter
...
207 |         core::ptr::copy_nonoverlapping(
    |         ------------------------------ arguments to this function are incorrect
208 |             data.as_ptr(),
209 |             aligned_data.as_ptr(),
    |             ^^^^^^^^^^^^^^^^^^^^^ expected `*mut T`, found `*mut u8`
    |
    = note: expected raw pointer `*mut T`
               found raw pointer `*mut u8`
note: function defined here
   --> C:\Users\Eric\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr\mod.rs:526:21
    |
526 | pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
    |                     ^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> kernel\src\memory\cache.rs:218:13
    |
189 | pub fn optimize_data_layout<T>(data: &mut [T]) -> MemoryResult<()>
    |                             - found this type parameter
...
216 |         core::ptr::copy_nonoverlapping(
    |         ------------------------------ arguments to this function are incorrect
217 |             aligned_data.as_ptr(),
218 |             data.as_mut_ptr(),
    |             ^^^^^^^^^^^^^^^^^ expected `*mut u8`, found `*mut T`
    |
    = note: expected raw pointer `*mut u8`
               found raw pointer `*mut T`
note: function defined here
   --> C:\Users\Eric\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr\mod.rs:526:21
    |
526 | pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
    |                     ^^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\dma.rs:227:19
    |
227 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\dma.rs:292:19
    |
292 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> kernel\src\memory\dma.rs:400:16
    |
400 |         if let Some(physical_addr) = crate::memory::virtual_mem::get_physical_address(current_addr) {
    |                ^^^^^^^^^^^^^^^^^^^   -------------------------------------------------------------- this expression has type `Result<Option<PhysicalAddress>, MemoryError>`
    |                |
    |                expected `Result<Option<PhysicalAddress>, ...>`, found `Option<_>`
    |
    = note: expected enum `Result<Option<PhysicalAddress>, MemoryError>`
               found enum `Option<_>`
help: try wrapping the pattern in `core::prelude::v1::Ok`
    |
400 |         if let core::prelude::v1::Ok(Some(physical_addr)) = crate::memory::virtual_mem::get_physical_address(current_addr) {
    |                ++++++++++++++++++++++                   +

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\mmap.rs:227:19
    |
227 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\mmap.rs:292:19
    |
292 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> kernel\src\memory\mmap.rs:400:16
    |
400 |         if let Some(physical_addr) = crate::memory::virtual_mem::get_physical_address(current_addr) {
    |                ^^^^^^^^^^^^^^^^^^^   -------------------------------------------------------------- this expression has type `Result<Option<PhysicalAddress>, MemoryError>`
    |                |
    |                expected `Result<Option<PhysicalAddress>, ...>`, found `Option<_>`
    |
    = note: expected enum `Result<Option<PhysicalAddress>, MemoryError>`
               found enum `Option<_>`
help: try wrapping the pattern in `core::prelude::v1::Ok`
    |
400 |         if let core::prelude::v1::Ok(Some(physical_addr)) = crate::memory::virtual_mem::get_physical_address(current_addr) {
    |                ++++++++++++++++++++++                   +

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:214:38
    |
204 | pub fn init() -> MemoryResult<()> {
    |                  ---------------- expected `MemoryError` because of this
...
214 |         arch::protection::enable_nx()?;
    |         -----------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |         |
    |         this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:222:42
    |
204 | pub fn init() -> MemoryResult<()> {
    |                  ---------------- expected `MemoryError` because of this
...
222 |         arch::protection::init_aslr_rng()?;
    |         ---------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |         |
    |         this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\protection.rs:256:64
    |
256 |     let mut protection = arch::protection::get_page_protection(address)?;
    |                          ------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |                          |
    |                          arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:166:12
    |
166 |     pub fn get_page_protection(_address: usize) -> Result<PageProtection, ()> {
    |            ^^^^^^^^^^^^^^^^^^^ ---------------

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:256:72
    |
249 | pub fn apply_nx_protection(address: VirtualAddress) -> MemoryResult<()> {
    |                                                        ---------------- expected `MemoryError` because of this
...
256 |     let mut protection = arch::protection::get_page_protection(address)?;
    |                          ----------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                          |
    |                          this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\protection.rs:266:47
    |
266 |         arch::protection::set_page_protection(address, protection)?;
    |         ------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |         |
    |         arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:170:12
    |
170 |     pub fn set_page_protection(_address: usize, _protection: PageProtection) -> Result<(), ()> {
    |            ^^^^^^^^^^^^^^^^^^^ ---------------

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:266:67
    |
249 | pub fn apply_nx_protection(address: VirtualAddress) -> MemoryResult<()> {
    |                                                        ---------------- expected `MemoryError` because of this
...
266 |         arch::protection::set_page_protection(address, protection)?;
    |         ----------------------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |         |
    |         this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\protection.rs:370:60
    |
370 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |                      |
    |                      arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:166:12
    |
166 |     pub fn get_page_protection(_address: usize) -> Result<PageProtection, ()> {
    |            ^^^^^^^^^^^^^^^^^^^ ---------------

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:370:68
    |
369 | pub fn is_executable(address: VirtualAddress) -> MemoryResult<bool> {
    |                                                  ------------------ expected `MemoryError` because of this
370 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ----------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                      |
    |                      this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\protection.rs:376:60
    |
376 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |                      |
    |                      arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:166:12
    |
166 |     pub fn get_page_protection(_address: usize) -> Result<PageProtection, ()> {
    |            ^^^^^^^^^^^^^^^^^^^ ---------------

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:376:68
    |
375 | pub fn is_writable(address: VirtualAddress) -> MemoryResult<bool> {
    |                                                ------------------ expected `MemoryError` because of this
376 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ----------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                      |
    |                      this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
   --> kernel\src\memory\protection.rs:388:60
    |
388 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ------------------------------------- ^^^^^^^ expected `usize`, found `VirtualAddress`
    |                      |
    |                      arguments to this function are incorrect
    |
note: function defined here
   --> kernel\src\arch\mod.rs:166:12
    |
166 |     pub fn get_page_protection(_address: usize) -> Result<PageProtection, ()> {
    |            ^^^^^^^^^^^^^^^^^^^ ---------------

error[E0277]: `?` couldn't convert the error to `MemoryError`
   --> kernel\src\memory\protection.rs:388:68
    |
381 | pub fn handle_protection_violation(address: VirtualAddress) -> MemoryResult<()> {
    |                                                                ---------------- expected `MemoryError` because of this
...
388 |     let protection = arch::protection::get_page_protection(address)?;
    |                      ----------------------------------------------^ the trait `From<()>` is not implemented for `MemoryError`
    |                      |
    |                      this can't be annotated with `?` because it has type `Result<_, ()>`
    |
note: `MemoryError` needs to implement `From<()>`
   --> kernel\src\memory\mod.rs:145:1
    |
145 | pub enum MemoryError {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0308]: mismatched types
  --> kernel\src\memory\mod.rs:63:40
   |
63 |     VirtualAddress::new(phys.value() + crate::arch::KERNEL_VIRTUAL_OFFSET)
   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot add `u64` to `usize`
  --> kernel\src\memory\mod.rs:63:38
   |
63 |     VirtualAddress::new(phys.value() + crate::arch::KERNEL_VIRTUAL_OFFSET)
   |                                      ^ no implementation for `usize + u64`
   |
   = help: the trait `Add<u64>` is not implemented for `usize`
   = help: the following other types implement trait `Add<Rhs>`:
             `&usize` implements `Add<usize>`
             `&usize` implements `Add`
             `usize` implements `Add<&usize>`
             `usize` implements `Add<zerocopy::byteorder::Usize<O>>`
             `usize` implements `Add`

error[E0308]: mismatched types
  --> kernel\src\memory\mod.rs:67:41
   |
67 |     PhysicalAddress::new(virt.value() - crate::arch::KERNEL_VIRTUAL_OFFSET)
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot subtract `u64` from `usize`
  --> kernel\src\memory\mod.rs:67:39
   |
67 |     PhysicalAddress::new(virt.value() - crate::arch::KERNEL_VIRTUAL_OFFSET)
   |                                       ^ no implementation for `usize - u64`
   |
   = help: the trait `Sub<u64>` is not implemented for `usize`
   = help: the following other types implement trait `Sub<Rhs>`:
             `&usize` implements `Sub<usize>`
             `&usize` implements `Sub`
             `usize` implements `Sub<&usize>`
             `usize` implements `Sub<zerocopy::byteorder::Usize<O>>`
             `usize` implements `Sub`

error[E0308]: mismatched types
   --> kernel\src\memory\mod.rs:124:19
    |
124 |         self.0 >= crate::arch::KERNEL_BASE
    |         ------    ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u64`
    |         |
    |         expected because this is `usize`
    |
help: you can convert a `u64` to a `usize` and panic if the converted value doesn't fit
    |
124 |         self.0 >= crate::arch::KERNEL_BASE.try_into().unwrap()
    |                                           ++++++++++++++++++++

error[E0599]: no method named `unwrap_or` found for struct `PanicMessage<'a>` in the current scope
  --> kernel\src\panic.rs:17:55
   |
17 |     writeln!(logger, "\n\n[PANIC] {}", info.message().unwrap_or(&format_args!("Unknown panic"))).ok();
   |                                                       ^^^^^^^^^ method not found in `PanicMessage<'_>`

warning: unreachable statement
  --> kernel\src\panic.rs:56:5
   |
53 |       crate::boot::enter_recovery_mode();
   |       ---------------------------------- any code following this expression is unreachable
...
56 | /     panic_handler(&PanicInfo::internal_constructor(
57 | |         core::panic::Location::caller(),
58 | |         message,
59 | |         None,
60 | |     ));
   | |_______^ unreachable statement

error[E0599]: no function or associated item named `internal_constructor` found for struct `PanicInfo<'a>` in the current scope
  --> kernel\src\panic.rs:56:31
   |
56 |     panic_handler(&PanicInfo::internal_constructor(
   |                               ^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `PanicInfo<'_>`

error[E0599]: no method named `unwrap_or` found for struct `PanicMessage<'a>` in the current scope
  --> kernel\src\panic.rs:77:54
   |
77 |     write!(&mut writer, "[PANIC] {}", info.message().unwrap_or(&format_args!("Unknown panic"))).ok();
   |                                                      ^^^^^^^^^ method not found in `PanicMessage<'_>`

error[E0308]: mismatched types
    --> kernel\src\logger.rs:62:34
     |
  62 |     SERIAL_LOGGER.lock().replace(Some(SerialLogger::new()));
     |                          ------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `SerialLogger`, found `Option<SerialLogger>`
     |                          |
     |                          arguments to this method are incorrect
     |
     = note: expected struct `SerialLogger`
                  found enum `Option<SerialLogger>`
help: the return type of this call is `Option<SerialLogger>` due to the type of the argument passed
    --> kernel\src\logger.rs:62:5
     |
  62 |     SERIAL_LOGGER.lock().replace(Some(SerialLogger::new()));
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------------------^
     |                                  |
     |                                  this argument influences the return type of `replace`
note: method defined here
    --> C:\Users\Eric\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\option.rs:1894:18
     |
1894 |     pub const fn replace(&mut self, value: T) -> Option<T> {
     |                  ^^^^^^^

error[E0277]: `LogLevel` doesn't implement `Display`
  --> kernel\src\logger.rs:52:28
   |
35 |             writeln!(logger, "[{}] {}", $level, format_args!($($arg)+)).ok();
   |                                -- required by this formatting parameter
...
52 |     ($($arg:tt)+) => (log!(crate::logger::LogLevel::Info, $($arg)+))
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `LogLevel` cannot be formatted with the default formatter
...
71 |     info!("Logger initialized");
   |     --------------------------- in this macro invocation
   |
help: the trait `Display` is not implemented for `LogLevel`
  --> kernel\src\logger.rs:12:1
   |
12 | pub enum LogLevel {
   | ^^^^^^^^^^^^^^^^^
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `info` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `to_string` found for type `char` in the current scope
    --> kernel\src\logger.rs:145:42
     |
 145 |                 return self.write_str(&c.to_string());
     |                                          ^^^^^^^^^ method not found in `char`
     |
    ::: C:\Users\Eric\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\string.rs:2772:8
     |
2772 |     fn to_string(&self) -> String;
     |        --------- the method is available for `char` here
     |
     = help: items from traits can only be used if the trait is in scope
help: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it
     |
   6 + use crate::alloc::string::ToString;
     |

warning: unused variable: `edx`
  --> kernel\src\arch\x86_64\cpu\cpuid.rs:68:29
   |
68 |         let (eax, ebx, ecx, edx) = unsafe { cpuid_ext(4, i) };
   |                             ^^^
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
   |
68 |         let (eax, ebx, ecx, _edx) = unsafe { cpuid_ext(4, i) };
   |                             +
help: you might have meant to pattern match on the similarly named constant `MULTIBOOT2_MAGIC`
   |
68 -         let (eax, ebx, ecx, edx) = unsafe { cpuid_ext(4, i) };
68 +         let (eax, ebx, ecx, boot::phases::MULTIBOOT2_MAGIC) = unsafe { cpuid_ext(4, i) };
   |

error[E0004]: non-exhaustive patterns: `msr::Msr::LastBranch0FromIp` and `msr::Msr::LastBranch0ToIp` not covered
   --> kernel\src\arch\x86_64\cpu\msr.rs:288:11
    |
288 |     match msr {
    |           ^^^ patterns `msr::Msr::LastBranch0FromIp` and `msr::Msr::LastBranch0ToIp` not covered
    |
note: `msr::Msr` defined here
   --> kernel\src\arch\x86_64\cpu\msr.rs:32:10
    |
 32 | pub enum Msr {
    |          ^^^
...
106 |     LastBranch0FromIp = 0x00000040,
    |     ----------------- not covered
...
109 |     LastBranch0ToIp = 0x00000060,
    |     --------------- not covered
    = note: the matched value is of type `msr::Msr`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms
    |
302 ~         },
303 ~         msr::Msr::LastBranch0FromIp | msr::Msr::LastBranch0ToIp => todo!(),
    |

warning: unused variable: `pdp_table`
   --> kernel\src\arch\x86_64\memory\paging.rs:131:13
    |
131 |         let pdp_table = self.get_or_create_table(0, indices.pml4)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pdp_table`

warning: unused variable: `pd_table`
   --> kernel\src\arch\x86_64\memory\paging.rs:134:13
    |
134 |         let pd_table = self.get_or_create_table(1, indices.pdp)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pd_table`

warning: unused variable: `level`
   --> kernel\src\arch\x86_64\memory\paging.rs:158:9
    |
158 |         level: usize,
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
158 |         _level: usize,
    |         +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
158 -         level: usize,
158 +         memory::cache::CACHE_LINE_SIZE: usize,
    |

warning: unused variable: `index`
   --> kernel\src\arch\x86_64\memory\paging.rs:159:9
    |
159 |         index: usize,
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
159 |         _index: usize,
    |         +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
159 -         index: usize,
159 +         memory::cache::CACHE_LINE_SIZE: usize,
    |

warning: unused variable: `phys_addr`
   --> kernel\src\arch\x86_64\memory\numa.rs:176:21
    |
176 | pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
    |                     ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 | pub fn migrate_page(_phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
    |                     +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
176 - pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
176 + pub fn migrate_page(memory::cache::CACHE_LINE_SIZE: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
    |

warning: unused variable: `from_node`
   --> kernel\src\arch\x86_64\memory\numa.rs:176:39
    |
176 | pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
    |                                       ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 | pub fn migrate_page(phys_addr: usize, _from_node: usize, to_node: usize) -> Result<(), ()> {
    |                                       +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
176 - pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
176 + pub fn migrate_page(phys_addr: usize, memory::cache::CACHE_LINE_SIZE: usize, to_node: usize) -> Result<(), ()> {
    |

warning: unused variable: `to_node`
   --> kernel\src\arch\x86_64\memory\numa.rs:176:57
    |
176 | pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
    |                                                         ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 | pub fn migrate_page(phys_addr: usize, from_node: usize, _to_node: usize) -> Result<(), ()> {
    |                                                         +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
176 - pub fn migrate_page(phys_addr: usize, from_node: usize, to_node: usize) -> Result<(), ()> {
176 + pub fn migrate_page(phys_addr: usize, from_node: usize, memory::cache::CACHE_LINE_SIZE: usize) -> Result<(), ()> {
    |

warning: unused variable: `virt_addr`
   --> kernel\src\arch\x86_64\memory\numa.rs:188:24
    |
188 | pub fn numa_alloc_hint(virt_addr: usize) -> Option<usize> {
    |                        ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
188 | pub fn numa_alloc_hint(_virt_addr: usize) -> Option<usize> {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
188 - pub fn numa_alloc_hint(virt_addr: usize) -> Option<usize> {
188 + pub fn numa_alloc_hint(memory::cache::CACHE_LINE_SIZE: usize) -> Option<usize> {
    |

error[E0597]: `idt` does not live long enough
   --> kernel\src\arch\x86_64\interrupts\idt.rs:140:5
    |
134 |     let mut idt = Idt::new();
    |         ------- binding `idt` declared here
...
140 |     idt.load();
    |     ^^^-------
    |     |
    |     borrowed value does not live long enough
    |     argument requires that `idt` is borrowed for `'static`
...
143 | }
    | - `idt` dropped here while still borrowed

error[E0716]: temporary value dropped while borrowed
   --> kernel\src\arch\x86_64\interrupts\idt.rs:171:5
    |
171 |     manager.idt.lock().as_ref().unwrap().load();
    |     ^^^^^^^^^^^^^^^^^^-------------------------- temporary value is freed at the end of this statement
    |     |
    |     creates a temporary value which is freed while still in use
    |     argument requires that borrow lasts for `'static`

warning: unused variable: `ist_index`
   --> kernel\src\arch\x86_64\interrupts\idt.rs:527:22
    |
527 | pub fn get_ist_stack(ist_index: usize) -> Option<usize> {
    |                      ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
527 | pub fn get_ist_stack(_ist_index: usize) -> Option<usize> {
    |                      +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
527 - pub fn get_ist_stack(ist_index: usize) -> Option<usize> {
527 + pub fn get_ist_stack(memory::cache::CACHE_LINE_SIZE: usize) -> Option<usize> {
    |

warning: variable does not need to be mutable
   --> kernel\src\arch\x86_64\interrupts\apic.rs:368:13
    |
368 |         let mut apic_ref = apic.as_mut().unwrap();
    |             ----^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `msi_addr`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:301:5
    |
301 |     msi_addr: u64,
    |     ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
301 |     _msi_addr: u64,
    |     +
help: you might have meant to pattern match on the similarly named constant `DMA_MAX_ADDRESS`
    |
301 -     msi_addr: u64,
301 +     arch::dma::DMA_MAX_ADDRESS: u64,
    |

warning: unused variable: `msi_data`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:302:5
    |
302 |     msi_data: u32,
    |     ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
302 |     _msi_data: u32,
    |     +
help: you might have meant to pattern match on the similarly named constant `MULTIBOOT2_MAGIC`
    |
302 -     msi_data: u32,
302 +     boot::phases::MULTIBOOT2_MAGIC: u32,
    |

warning: unused variable: `active_low`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:306:5
    |
306 |     active_low: bool,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_active_low`

warning: unused variable: `level_triggered`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:336:5
    |
336 |     level_triggered: bool,
    |     ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_level_triggered`

warning: unused variable: `active_low`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:337:5
    |
337 |     active_low: bool,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_active_low`

warning: unused variable: `syscall_num`
   --> kernel\src\arch\x86_64\mod.rs:108:22
    |
108 |     fn syscall_entry(syscall_num: usize, args: &[usize]) -> isize {
    |                      ^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
108 |     fn syscall_entry(_syscall_num: usize, args: &[usize]) -> isize {
    |                      +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
108 -     fn syscall_entry(syscall_num: usize, args: &[usize]) -> isize {
108 +     fn syscall_entry(memory::cache::CACHE_LINE_SIZE: usize, args: &[usize]) -> isize {
    |

warning: unused variable: `args`
   --> kernel\src\arch\x86_64\mod.rs:108:42
    |
108 |     fn syscall_entry(syscall_num: usize, args: &[usize]) -> isize {
    |                                          ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: value assigned to `eax` is never read
   --> kernel\src\arch\x86_64\mod.rs:150:17
    |
150 |         let mut eax: u32 = 0;
    |                 ^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `edx` is never read
   --> kernel\src\arch\x86_64\mod.rs:151:17
    |
151 |         let mut edx: u32 = 0;
    |                 ^^^
    |
    = help: maybe it is overwritten before being read?

error[E0382]: borrow of moved value: `name`
   --> kernel\src\boot\phases.rs:166:57
    |
151 |         let name = if name_ptr != 0 {
    |             ---- move occurs because `name` has type `String`, which does not implement the `Copy` trait
...
163 |             name,
    |             ---- value moved here
...
166 |         log::info!("Module loaded: {} (0x{:x}-0x{:x})", name, start, end);
    |                                                         ^^^^ value borrowed here after move
    |
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::info` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
    |
163 |             name: name.clone(),
    |                 ++++++++++++++

warning: unused variable: `boot_info`
  --> kernel\src\boot\late_init.rs:79:16
   |
79 | pub fn init_ai(boot_info: &BootInfo) -> Result<(), ArchError> {
   |                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_boot_info`

warning: unused variable: `bitmap`
   --> kernel\src\memory\physical\bitmap_allocator.rs:126:13
    |
126 |         let bitmap = self.bitmap.as_mut().ok_or(MemoryError::InternalError("Bitmap not allocated"))?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_bitmap`

warning: unused variable: `zone`
   --> kernel\src\memory\physical\bitmap_allocator.rs:149:40
    |
149 |     pub fn allocate_in_zone(&mut self, zone: MemoryZone) -> MemoryResult<Frame> {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_zone`

warning: unused variable: `node`
   --> kernel\src\memory\physical\bitmap_allocator.rs:160:40
    |
160 |     pub fn allocate_on_node(&mut self, node: u32) -> MemoryResult<Frame> {
    |                                        ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
160 |     pub fn allocate_on_node(&mut self, _node: u32) -> MemoryResult<Frame> {
    |                                        +
help: you might have meant to pattern match on the similarly named constant `MULTIBOOT2_MAGIC`
    |
160 -     pub fn allocate_on_node(&mut self, node: u32) -> MemoryResult<Frame> {
160 +     pub fn allocate_on_node(&mut self, boot::phases::MULTIBOOT2_MAGIC: u32) -> MemoryResult<Frame> {
    |

warning: unused variable: `zone`
   --> kernel\src\memory\physical\buddy_allocator.rs:134:40
    |
134 |     pub fn allocate_in_zone(&mut self, zone: MemoryZone) -> MemoryResult<Frame> {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_zone`

warning: unused variable: `node`
   --> kernel\src\memory\physical\buddy_allocator.rs:141:40
    |
141 |     pub fn allocate_on_node(&mut self, node: u32) -> MemoryResult<Frame> {
    |                                        ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
141 |     pub fn allocate_on_node(&mut self, _node: u32) -> MemoryResult<Frame> {
    |                                        +
help: you might have meant to pattern match on the similarly named constant `MULTIBOOT2_MAGIC`
    |
141 -     pub fn allocate_on_node(&mut self, node: u32) -> MemoryResult<Frame> {
141 +     pub fn allocate_on_node(&mut self, boot::phases::MULTIBOOT2_MAGIC: u32) -> MemoryResult<Frame> {
    |

warning: unused variable: `next`
   --> kernel\src\memory\physical\buddy_allocator.rs:266:30
    |
266 |                         Some(next) => {
    |                              ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
266 |                         Some(_next) => {
    |                              +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
266 -                         Some(next) => {
266 +                         Some(memory::cache::CACHE_LINE_SIZE) => {
    |

warning: variable does not need to be mutable
   --> kernel\src\memory\physical\buddy_allocator.rs:258:21
    |
258 |                 let mut current = block;
    |                     ----^^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `block`
   --> kernel\src\memory\physical\buddy_allocator.rs:364:25
    |
364 |             if let Some(block) = &self.free_lists[order] {
    |                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_block`

warning: unused variable: `middle`
   --> kernel\src\memory\physical\zone.rs:343:22
    |
343 |                 let (middle, last) = middle.split_at(end)?;
    |                      ^^^^^^ help: if this is intentional, prefix it with an underscore: `_middle`

error[E0502]: cannot borrow `self.regions` as immutable because it is also borrowed as mutable
   --> kernel\src\memory\physical\zone.rs:346:29
    |
339 |         for region in &mut self.regions {
    |                       ----------------- mutable borrow occurs here
...
346 |                 let index = self.regions.iter().position(|r| core::ptr::eq(r, region)).unwrap();
    |                             ^^^^^^^^^^^^ immutable borrow occurs here         ------ mutable borrow later captured here by closure

warning: unused variable: `size`
  --> kernel\src\memory\physical\numa.rs:65:37
   |
65 |     pub fn record_allocation(&self, size: usize) {
   |                                     ^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
65 |     pub fn record_allocation(&self, _size: usize) {
   |                                     +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
   |
65 -     pub fn record_allocation(&self, size: usize) {
65 +     pub fn record_allocation(&self, memory::cache::CACHE_LINE_SIZE: usize) {
   |

warning: unused variable: `size`
  --> kernel\src\memory\physical\numa.rs:71:39
   |
71 |     pub fn record_deallocation(&self, size: usize) {
   |                                       ^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
71 |     pub fn record_deallocation(&self, _size: usize) {
   |                                       +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
   |
71 -     pub fn record_deallocation(&self, size: usize) {
71 +     pub fn record_deallocation(&self, memory::cache::CACHE_LINE_SIZE: usize) {
   |

warning: unused variable: `entry_index`
   --> kernel\src\memory\virtual_mem\page_table.rs:289:29
    |
289 |         for (table_address, entry_index) in tables_to_free.iter().rev() {
    |                             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_entry_index`

warning: variable does not need to be mutable
   --> kernel\src\memory\virtual_mem\page_table.rs:290:17
    |
290 |             let mut table = PageTable::from_physical(*table_address, 0)?;
    |                 ----^^^^^
    |                 |
    |                 help: remove this `mut`

error[E0382]: use of moved value: `region`
   --> kernel\src\memory\virtual_mem\address_space.rs:250:33
    |
241 |     pub fn add_region(&mut self, region: MemoryRegion) -> MemoryResult<()> {
    |                                  ------ move occurs because `region` has type `address_space::MemoryRegion`, which does not implement the `Copy` trait
...
249 |         self.regions.push(region);
    |                           ------ value moved here
250 |         self.stats.used_size += region.size;
    |                                 ^^^^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
249 |         self.regions.push(region.clone());
    |                                 ++++++++

warning: unused variable: `end`
   --> kernel\src\memory\virtual_mem\address_space.rs:257:13
    |
257 |         let end = VirtualAddress::new(start.value() + size);
    |             ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
257 |         let _end = VirtualAddress::new(start.value() + size);
    |             +
help: you might have meant to pattern match on the similarly named constant `KERNEL_CODE_END`
    |
257 -         let end = VirtualAddress::new(start.value() + size);
257 +         let arch::x86_64::KERNEL_CODE_END = VirtualAddress::new(start.value() + size);
    |

warning: variable does not need to be mutable
   --> kernel\src\memory\virtual_mem\address_space.rs:395:9
    |
395 |     let mut address_space = AddressSpace {
    |         ----^^^^^^^^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `is_user`
   --> kernel\src\memory\virtual_mem\mod.rs:305:9
    |
305 |     let is_user = (error_code & 0x4) != 0;
    |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_is_user`

warning: unused variable: `i`
   --> kernel\src\memory\heap\thread_cache.rs:215:14
    |
215 |         for (i, free_list) in self.free_lists.iter_mut().enumerate() {
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
215 |         for (_i, free_list) in self.free_lists.iter_mut().enumerate() {
    |              +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
215 -         for (i, free_list) in self.free_lists.iter_mut().enumerate() {
215 +         for (memory::cache::CACHE_LINE_SIZE, free_list) in self.free_lists.iter_mut().enumerate() {
    |

warning: unused variable: `alignment`
   --> kernel\src\memory\heap\cpu_slab.rs:363:42
    |
363 |     pub fn alloc(&mut self, size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
    |                                          ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
363 |     pub fn alloc(&mut self, size: usize, _alignment: usize) -> MemoryResult<NonNull<u8>> {
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
363 -     pub fn alloc(&mut self, size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
363 +     pub fn alloc(&mut self, size: usize, memory::cache::CACHE_LINE_SIZE: usize) -> MemoryResult<NonNull<u8>> {
    |

warning: unused variable: `slab_class`
   --> kernel\src\memory\heap\cpu_slab.rs:422:13
    |
422 |         for slab_class in &self.slabs {
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_slab_class`

warning: unused variable: `slab_class`
   --> kernel\src\memory\heap\cpu_slab.rs:438:13
    |
438 |         for slab_class in &mut self.slabs {
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_slab_class`

warning: variable does not need to be mutable
   --> kernel\src\memory\heap\cpu_slab.rs:435:13
    |
435 |         let mut freed_pages = 0;
    |             ----^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `page`
   --> kernel\src\memory\heap\slab.rs:166:13
    |
166 |         let page = self.create_page_info(virtual_address, size, true)?;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_page`

warning: unused variable: `alignment`
   --> kernel\src\memory\heap\slab.rs:147:44
    |
147 |     fn alloc_large(&mut self, size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
    |                                            ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
147 |     fn alloc_large(&mut self, size: usize, _alignment: usize) -> MemoryResult<NonNull<u8>> {
    |                                            +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
147 -     fn alloc_large(&mut self, size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
147 +     fn alloc_large(&mut self, size: usize, memory::cache::CACHE_LINE_SIZE: usize) -> MemoryResult<NonNull<u8>> {
    |

warning: unused variable: `size`
   --> kernel\src\memory\heap\slab.rs:266:48
    |
266 |     fn can_fit_in_page(&self, page: &SlabPage, size: usize, alignment: usize) -> bool {
    |                                                ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
266 |     fn can_fit_in_page(&self, page: &SlabPage, _size: usize, alignment: usize) -> bool {
    |                                                +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
266 -     fn can_fit_in_page(&self, page: &SlabPage, size: usize, alignment: usize) -> bool {
266 +     fn can_fit_in_page(&self, page: &SlabPage, memory::cache::CACHE_LINE_SIZE: usize, alignment: usize) -> bool {
    |

warning: unused variable: `alignment`
   --> kernel\src\memory\heap\slab.rs:266:61
    |
266 |     fn can_fit_in_page(&self, page: &SlabPage, size: usize, alignment: usize) -> bool {
    |                                                             ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
266 |     fn can_fit_in_page(&self, page: &SlabPage, size: usize, _alignment: usize) -> bool {
    |                                                             +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
266 -     fn can_fit_in_page(&self, page: &SlabPage, size: usize, alignment: usize) -> bool {
266 +     fn can_fit_in_page(&self, page: &SlabPage, size: usize, memory::cache::CACHE_LINE_SIZE: usize) -> bool {
    |

warning: unnecessary `unsafe` block
   --> kernel\src\memory\heap\slab.rs:282:19
    |
282 |         let ptr = unsafe {
    |                   ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `virtual_address`
   --> kernel\src\memory\heap\slab.rs:316:36
    |
316 |     fn create_page_info(&mut self, virtual_address: VirtualAddress, size: usize, is_large: bool) -> MemoryResult<*mut SlabPage> {
    |                                    ^^^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
316 |     fn create_page_info(&mut self, _virtual_address: VirtualAddress, size: usize, is_large: bool) -> MemoryResult<*mut SlabPage> {
    |                                    +
help: you might have meant to pattern match on the similarly named constant `KERNEL_CODE_END`
    |
316 -     fn create_page_info(&mut self, virtual_address: VirtualAddress, size: usize, is_large: bool) -> MemoryResult<*mut SlabPage> {
316 +     fn create_page_info(&mut self, arch::x86_64::KERNEL_CODE_END: VirtualAddress, size: usize, is_large: bool) -> MemoryResult<*mut SlabPage> {
    |

warning: unused variable: `ptr`
   --> kernel\src\memory\heap\slab.rs:388:37
    |
388 |     fn find_page_for_pointer(&self, ptr: NonNull<u8>) -> MemoryResult<*mut SlabPage> {
    |                                     ^^^ help: if this is intentional, prefix it with an underscore: `_ptr`

warning: unused variable: `ptr`
   --> kernel\src\memory\heap\slab.rs:407:52
    |
407 |     fn dealloc_in_page(&self, page: *mut SlabPage, ptr: NonNull<u8>, size: usize) -> MemoryResult<()> {
    |                                                    ^^^ help: if this is intentional, prefix it with an underscore: `_ptr`

warning: unused variable: `size`
   --> kernel\src\memory\heap\slab.rs:407:70
    |
407 |     fn dealloc_in_page(&self, page: *mut SlabPage, ptr: NonNull<u8>, size: usize) -> MemoryResult<()> {
    |                                                                      ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
407 |     fn dealloc_in_page(&self, page: *mut SlabPage, ptr: NonNull<u8>, _size: usize) -> MemoryResult<()> {
    |                                                                      +
help: you might have meant to pattern match on the similarly named constant `CACHE_LINE_SIZE`
    |
407 -     fn dealloc_in_page(&self, page: *mut SlabPage, ptr: NonNull<u8>, size: usize) -> MemoryResult<()> {
407 +     fn dealloc_in_page(&self, page: *mut SlabPage, ptr: NonNull<u8>, memory::cache::CACHE_LINE_SIZE: usize) -> MemoryResult<()> {
    |

Some errors have detailed explanations: E0004, E0061, E0107, E0277, E0282, E0308, E0382, E0412, E0422...
For more information about an error, try `rustc --explain E0004`.
warning: `exo-kernel` (lib) generated 113 warnings
warning: exo-kernel@0.2.0: Compiled boot.asm with NASM (path src/arch/x86_64/boot/boot.asm)
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled serial.c
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled windowed.S (provides context_switch symbol)
error: could not compile `exo-kernel` (lib) due to 219 previous errors; 113 warnings emitted
