    Blocking waiting for file lock on build directory
warning: exo-kernel@0.2.0: Compiled boot.asm with NASM (path src/arch/x86_64/boot/boot.asm)
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled serial.c
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled windowed.S (provides context_switch symbol)
warning: fields `path`, `size`, and `extra_flags` are never read
  --> libs\exo_types\src\capability.rs:67:5
   |
65 | pub struct CapabilityMetadata {
   |            ------------------ fields in this struct
66 |     /// Chemin ou nom pour les objets nomm├⌐s
67 |     path: Option<String>,
   |     ^^^^
...
70 |     size: Option<usize>,
   |     ^^^^
...
73 |     extra_flags: u32,
   |     ^^^^^^^^^^^
   |
   = note: `CapabilityMetadata` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `core::convert::TryInto`
 --> libs\exo_crypto\src\chacha20.rs:4:5
  |
4 | use core::convert::TryInto;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `aad`
   --> libs\exo_crypto\src\chacha20.rs:283:23
    |
283 | fn poly1305(m: &[u8], aad: &[u8], key: &[u8; POLY1305_KEYBYTES]) -> [u8; POLY1305_TAGBYTES] {
    |                       ^^^ help: if this is intentional, prefix it with an underscore: `_aad`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `core::mem::MaybeUninit`
 --> libs\exo_ipc\src\channel.rs:5:5
  |
5 | use core::mem::MaybeUninit;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `MAX_INLINE_SIZE`, `MessageFlags`, and `MessageHeader`
 --> libs\exo_ipc\src\channel.rs:9:22
  |
9 | use crate::{Message, MessageFlags, MessageHeader, MAX_INLINE_SIZE, SLOT_SIZE};
  |                      ^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused import: `core::mem::size_of`
 --> libs\exo_ipc\src\message.rs:4:5
  |
4 | use core::mem::size_of;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused variable: `size`
   --> libs\exo_ipc\src\channel.rs:252:24
    |
252 | unsafe fn alloc_zeroed(size: usize) -> *mut u8 {
    |                        ^^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
252 | unsafe fn alloc_zeroed(_size: usize) -> *mut u8 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `SLOT_ALIGN`
    |
252 - unsafe fn alloc_zeroed(size: usize) -> *mut u8 {
252 + unsafe fn alloc_zeroed(SLOT_ALIGN: usize) -> *mut u8 {
    |

warning: field `capacity` is never read
  --> libs\exo_ipc\src\channel.rs:30:5
   |
28 | struct RingBuffer<T> {
   |        ---------- field in this struct
29 |     buffer: *mut T,
30 |     capacity: usize,
   |     ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `capacity` is never read
   --> libs\exo_ipc\src\channel.rs:101:5
    |
 90 | pub struct Channel<T> {
    |            ------- field in this struct
...
101 |     capacity: usize,
    |     ^^^^^^^^

warning: `exo_types` (lib) generated 1 warning
warning: `exo_crypto` (lib) generated 2 warnings (run `cargo fix --lib -p exo_crypto` to apply 1 suggestion)
warning: `exo_ipc` (lib) generated 6 warnings (run `cargo fix --lib -p exo_ipc` to apply 4 suggestions)
    Checking exo-kernel v0.2.0 (C:\Users\Eric\Documents\Exo-OS\kernel)
error[E0252]: the name `PageTableFlags` is defined multiple times
  --> kernel\src\memory\virtual_mem\page_table.rs:15:9
   |
10 | use super::PageTableFlags;
   |     --------------------- previous import of the type `PageTableFlags` here
...
15 | pub use super::PageTableFlags;
   |         ^^^^^^^^^^^^^^^^^^^^^ `PageTableFlags` reimported here
   |
   = note: `PageTableFlags` must be defined only once in the type namespace of this module

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:26:5
   |
26 |     fn get_resolution(&self) -> (usize, usize);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                               |
   |                                               help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:26:23
   |
26 |     fn get_resolution(&self) -> (usize, usize);
   |                       ^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:29:5
   |
29 |     fn get_pixel_format(&self) -> PixelFormat;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                              |
   |                                              help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:29:25
   |
29 |     fn get_pixel_format(&self) -> PixelFormat;
   |                         ^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:32:5
   |
32 |     fn set_pixel(&mut self, x: usize, y: usize, color: u32) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                                                      |
   |                                                                                      help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:32:18
   |
32 |     fn set_pixel(&mut self, x: usize, y: usize, color: u32) -> Result<(), VideoError>;
   |                  ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:36:5
   |
36 |     fn write_block(&mut self, x: usize, y: usize, width: usize, height: usize, data: &[u8]) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                                                                                      |
   |                                                                                                                      help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:36:20
   |
36 |     fn write_block(&mut self, x: usize, y: usize, width: usize, height: usize, data: &[u8]) -> Result<(), VideoError>;
   |                    ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:39:5
   |
39 |     fn set_cursor(&mut self, x: usize, y: usize) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                                           |
   |                                                                           help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:39:19
   |
39 |     fn set_cursor(&mut self, x: usize, y: usize) -> Result<(), VideoError>;
   |                   ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:42:5
   |
42 |     fn write_char(&mut self, c: char) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                                |
   |                                                                help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:42:19
   |
42 |     fn write_char(&mut self, c: char) -> Result<(), VideoError>;
   |                   ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:45:5
   |
45 |     fn clear(&mut self, color: u32) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                              |
   |                                                              help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:45:14
   |
45 |     fn clear(&mut self, color: u32) -> Result<(), VideoError>;
   |              ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error: free function without a body
  --> kernel\src\drivers\video\mod.rs:48:5
   |
48 |     fn swap_buffers(&mut self) -> Result<(), VideoError>;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                                                         |
   |                                                         help: provide a definition for the function: `{ <body> }`

error: `self` parameter is only allowed in associated functions
  --> kernel\src\drivers\video\mod.rs:48:21
   |
48 |     fn swap_buffers(&mut self) -> Result<(), VideoError>;
   |                     ^^^^^^^^^ not semantically valid as function parameter
   |
   = note: associated functions are those in `impl` or `trait` definitions

error[E0432]: unresolved imports `core::arch::x86_64::inb`, `core::arch::x86_64::outb`
 --> kernel\src\drivers\input\keyboard.rs:8:26
  |
8 | use core::arch::x86_64::{inb, outb};
  |                          ^^^  ^^^^ no `outb` in `core_arch::arch::x86_64`
  |                          |
  |                          no `inb` in `core_arch::arch::x86_64`

error[E0432]: unresolved imports `core::arch::x86_64::inl`, `core::arch::x86_64::outl`
 --> kernel\src\drivers\pci\config.rs:8:26
  |
8 | use core::arch::x86_64::{inl, outl};
  |                          ^^^  ^^^^ no `outl` in `core_arch::arch::x86_64`
  |                          |
  |                          no `inl` in `core_arch::arch::x86_64`

error[E0432]: unresolved import `volatile::Volatile`
 --> kernel\src\drivers\video\vga.rs:9:5
  |
9 | use volatile::Volatile;
  |     ^^^^^^^^^^^^^^^^^^ no `Volatile` in the root

error[E0432]: unresolved import `virtio_drivers`
  --> kernel\src\drivers\video\virtio_gpu.rs:12:5
   |
12 | use virtio_drivers::{VirtIOBlk, VirtIOHeader};
   |     ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `virtio_drivers`
   |
   = help: if you wanted to use a crate named `virtio_drivers`, use `cargo add virtio_drivers` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::VideoDriver`, `super::VideoError`
 --> kernel\src\drivers\video\vga.rs:7:13
  |
7 | use super::{VideoDriver, VideoError, PixelFormat, colors};
  |             ^^^^^^^^^^^  ^^^^^^^^^^ no `VideoError` in `drivers::video`
  |             |
  |             no `VideoDriver` in `drivers::video`

error[E0432]: unresolved imports `super::VideoDriver`, `super::VideoError`
 --> kernel\src\drivers\video\framebuffer.rs:7:13
  |
7 | use super::{VideoDriver, VideoError, PixelFormat};
  |             ^^^^^^^^^^^  ^^^^^^^^^^ no `VideoError` in `drivers::video`
  |             |
  |             no `VideoDriver` in `drivers::video`

error[E0432]: unresolved imports `super::VideoDriver`, `super::VideoError`
 --> kernel\src\drivers\video\virtio_gpu.rs:8:13
  |
8 | use super::{VideoDriver, VideoError, PixelFormat, colors};
  |             ^^^^^^^^^^^  ^^^^^^^^^^ no `VideoError` in `drivers::video`
  |             |
  |             no `VideoDriver` in `drivers::video`

error: cannot find macro `vec` in this scope
  --> kernel\src\drivers\input\hid.rs:68:19
   |
68 |             axes: vec![
   |                   ^^^
   |
help: consider importing one of these macros
   |
 7 + use crate::prelude::vec;
   |
 7 + use alloc::vec;
   |

error: cannot find macro `vec` in this scope
  --> kernel\src\drivers\input\hid.rs:72:22
   |
72 |             buttons: vec![
   |                      ^^^
   |
help: consider importing one of these macros
   |
 7 + use crate::prelude::vec;
   |
 7 + use alloc::vec;
   |

error: cannot find macro `vec` in this scope
   --> kernel\src\drivers\video\virtio_gpu.rs:170:28
    |
170 |         let mut row_data = vec![0; width * bytes_per_pixel];
    |                            ^^^
    |
help: consider importing one of these macros
    |
  8 + use crate::prelude::vec;
    |
  8 + use alloc::vec;
    |

error: cannot find macro `vec` in this scope
  --> kernel\src\drivers\block\ramdisk.rs:26:23
   |
26 |         let storage = vec![0u8; total_size as usize];
   |                       ^^^
   |
help: consider importing one of these macros
   |
 7 + use crate::prelude::vec;
   |
 7 + use alloc::vec;
   |

error: cannot find macro `println` in this scope
  --> kernel\src\drivers\video\mod.rs:97:5
   |
97 |     println!("[VIDEO] Falling back to VGA text mode.");
   |     ^^^^^^^

error: cannot find macro `println` in this scope
  --> kernel\src\drivers\video\mod.rs:88:9
   |
88 |         println!("[VIDEO] Generic framebuffer driver initialized.");
   |         ^^^^^^^

error: cannot find macro `println` in this scope
  --> kernel\src\drivers\video\mod.rs:79:9
   |
79 |         println!("[VIDEO] VirtIO GPU driver initialized.");
   |         ^^^^^^^

error: cannot find macro `println` in this scope
  --> kernel\src\drivers\video\mod.rs:75:5
   |
75 |     println!("[VIDEO] Initializing video subsystem...");
   |     ^^^^^^^

error: cannot find macro `println` in this scope
   --> kernel\src\drivers\video\virtio_gpu.rs:194:5
    |
194 |     println!("[VIRTIO_GPU] Probing for VirtIO GPU device...");
    |     ^^^^^^^

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\arch\x86_64\interrupts\apic.rs:266:16
    |
266 |         crate::time::sleep(1000);
    |                ^^^^
    |                |
    |                unresolved import
    |                help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\arch\x86_64\syscall.rs:70:23
   |
70 |     let args = crate::syscall::abi::SyscallArgs {
   |                       ^^^^^^^
   |                       |
   |                       unresolved import
   |                       help: a similar path exists: `arch::syscall`

error[E0433]: failed to resolve: could not find `gdt` in `x86_64`
  --> kernel\src\boot\early_init.rs:11:19
   |
11 |     arch::x86_64::gdt::init()
   |                   ^^^ could not find `gdt` in `x86_64`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:47:21
   |
47 |     if let Err(e) = drivers::timer::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:53:21
   |
53 |     if let Err(e) = drivers::serial::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:59:21
   |
59 |     if let Err(e) = drivers::keyboard::init() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `posix` in the crate root
  --> kernel\src\boot\late_init.rs:72:12
   |
72 |     crate::posix::init();
   |            ^^^^^ could not find `posix` in the crate root

error[E0433]: failed to resolve: could not find `security` in the crate root
   --> kernel\src\boot\late_init.rs:103:12
    |
103 |     crate::security::capabilities::init();
    |            ^^^^^^^^ could not find `security` in the crate root

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\late_init.rs:112:12
    |
112 |     crate::time::start_timer_service();
    |            ^^^^
    |            |
    |            unresolved import
    |            help: a similar path exists: `core::time`

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\recovery.rs:71:47
   |
71 |     if let Some(event) = crate::arch::x86_64::c_compat::keyboard_read_event() {
   |                                               ^^^^^^^^ could not find `c_compat` in `x86_64`

error[E0433]: failed to resolve: unresolved import
  --> kernel\src\boot\mod.rs:97:29
   |
97 |     let boot_start = crate::time::get_time();
   |                             ^^^^
   |                             |
   |                             unresolved import
   |                             help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\mod.rs:102:32
    |
102 |     let critical_time = crate::time::get_time() - boot_start;
    |                                ^^^^
    |                                |
    |                                unresolved import
    |                                help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\mod.rs:112:30
    |
112 |     let normal_time = crate::time::get_time() - boot_start - critical_time;
    |                              ^^^^
    |                              |
    |                              unresolved import
    |                              help: a similar path exists: `core::time`

error[E0433]: failed to resolve: unresolved import
   --> kernel\src\boot\mod.rs:122:29
    |
122 |     let total_time = crate::time::get_time() - boot_start;
    |                             ^^^^
    |                             |
    |                             unresolved import
    |                             help: a similar path exists: `core::time`

error[E0433]: failed to resolve: could not find `fs` in the crate root
   --> kernel\src\memory\dma.rs:337:23
    |
337 |     let file = crate::fs::get_file_descriptor(fd)?;
    |                       ^^ could not find `fs` in the crate root

error[E0433]: failed to resolve: could not find `fs` in the crate root
   --> kernel\src\memory\mmap.rs:337:23
    |
337 |     let file = crate::fs::get_file_descriptor(fd)?;
    |                       ^^ could not find `fs` in the crate root

error[E0433]: failed to resolve: could not find `process` in the crate root
   --> kernel\src\memory\protection.rs:395:16
    |
395 |         crate::process::terminate_current_process(1);
    |                ^^^^^^^ could not find `process` in the crate root

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\panic.rs:28:22
   |
28 |         crate::arch::current_arch::print_backtrace(&mut logger);
   |                      ^^^^^^^^^^^^
   |                      |
   |                      expected type, found function `current_arch` in `arch`
   |                      help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: expected type, found function `current_arch` in `arch`
  --> kernel\src\panic.rs:32:34
   |
32 |     if let Err(e) = crate::arch::current_arch::shutdown() {
   |                                  ^^^^^^^^^^^^
   |                                  |
   |                                  expected type, found function `current_arch` in `arch`
   |                                  help: a struct with a similar name exists: `CurrentArch`

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
  --> kernel\src\logger.rs:95:20
   |
95 |     serial: crate::c_compat::SerialPort,
   |                    ^^^^^^^^ could not find `c_compat` in the crate root

error[E0425]: cannot find value `ap_id` in this scope
  --> kernel\src\arch\x86_64\cpu\smp.rs:75:9
   |
75 |         ap_id,
   |         ^^^^^ not found in this scope

error[E0425]: cannot find function `alloc_page` in module `crate::memory`
   --> kernel\src\arch\x86_64\memory\numa.rs:159:24
    |
159 |         crate::memory::alloc_page(flags)
    |                        ^^^^^^^^^^ help: a function with a similar name exists: `alloc_pages`
    |
   ::: kernel\src\memory\physical\mod.rs:317:1
    |
317 | pub fn allocate_frame() -> MemoryResult<Frame> {
    | ---------------------------------------------- similarly named function `alloc_pages` defined here

error[E0425]: cannot find value `HEAP` in module `crate::memory`
   --> kernel\src\arch\x86_64\memory\mod.rs:112:20
    |
112 |     crate::memory::HEAP.lock().replace(heap);
    |                    ^^^^ not found in `crate::memory`

error[E0425]: cannot find function `map_pages` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\apic.rs:108:24
    |
108 |         crate::memory::map_pages(
    |                        ^^^^^^^^^ not found in `crate::memory`

error[E0425]: cannot find function `map_pages` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:123:24
    |
123 |         crate::memory::map_pages(
    |                        ^^^^^^^^^ not found in `crate::memory`

error[E0425]: cannot find function `kernel_virt_to_phys` in module `crate::memory`
   --> kernel\src\arch\x86_64\interrupts\ioapic.rs:124:28
    |
124 |             crate::memory::kernel_virt_to_phys(ioapic_addr as usize),
    |                            ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory`

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:126:22
    |
126 |                 1 => MemoryType::Usable,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:127:22
    |
127 |                 2 => MemoryType::Reserved,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:128:22
    |
128 |                 3 => MemoryType::ACPI,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:129:22
    |
129 |                 4 => MemoryType::NVS,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0433]: failed to resolve: use of undeclared type `MemoryType`
   --> kernel\src\boot\multiboot2.rs:130:22
    |
130 |                 _ => MemoryType::BadMemory,
    |                      ^^^^^^^^^^ use of undeclared type `MemoryType`
    |
help: consider importing one of these enums
    |
  6 + use crate::arch::x86_64::MemoryType;
    |
  6 + use crate::memory::vm::MemoryType;
    |

error[E0422]: cannot find struct, variant or union type `MemoryRegion` in this scope
   --> kernel\src\boot\multiboot2.rs:133:26
    |
133 |             let region = MemoryRegion {
    |                          ^^^^^^^^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  6 + use crate::arch::x86_64::MemoryRegion;
    |
  6 + use crate::memory::physical::zone::MemoryRegion;
    |
  6 + use crate::memory::vm::MemoryRegion;
    |

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\early_init.rs:39:43
   |
39 |     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
   |                                           ^^^^^^^^ could not find `c_compat` in `x86_64`
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
39 -     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
39 +     let mut serial = SerialPort::new(0x3F8);
   |

error[E0433]: failed to resolve: could not find `c_compat` in `x86_64`
  --> kernel\src\boot\recovery.rs:78:43
   |
78 |     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
   |                                           ^^^^^^^^ could not find `c_compat` in `x86_64`
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
78 -     let mut serial = crate::arch::x86_64::c_compat::SerialPort::new(0x3F8);
78 +     let mut serial = SerialPort::new(0x3F8);
   |

error[E0425]: cannot find function `critical_phase` in module `phases`
   --> kernel\src\boot\mod.rs:100:13
    |
100 |     phases::critical_phase(boot_info)?;
    |             ^^^^^^^^^^^^^^ not found in `phases`

error[E0425]: cannot find function `normal_phase` in module `phases`
   --> kernel\src\boot\mod.rs:110:13
    |
110 |     phases::normal_phase(boot_info)?;
    |             ^^^^^^^^^^^^ not found in `phases`

error[E0425]: cannot find function `deferred_phase` in module `phases`
   --> kernel\src\boot\mod.rs:120:13
    |
120 |     phases::deferred_phase(boot_info)?;
    |             ^^^^^^^^^^^^^^ not found in `phases`

error[E0433]: failed to resolve: could not find `numa` in `arch`
   --> kernel\src\memory\physical\numa.rs:179:31
    |
179 |         let numa_info = arch::numa::detect_numa_topology()?;
    |                               ^^^^ could not find `numa` in `arch`
    |
help: consider importing this module
    |
  8 + use crate::arch::memory::numa;
    |
help: if you import `numa`, refer to it directly
    |
179 -         let numa_info = arch::numa::detect_numa_topology()?;
179 +         let numa_info = numa::detect_numa_topology()?;
    |

error[E0433]: failed to resolve: could not find `MemoryRegionType` in `virtual_mem`
   --> kernel\src\memory\shared\mod.rs:122:41
    |
122 |             crate::memory::virtual_mem::MemoryRegionType::Mmap,
    |                                         ^^^^^^^^^^^^^^^^ could not find `MemoryRegionType` in `virtual_mem`
    |
help: a struct with a similar name exists
    |
122 -             crate::memory::virtual_mem::MemoryRegionType::Mmap,
122 +             crate::memory::virtual_mem::MemoryRegion::Mmap,
    |
help: consider importing one of these enums
    |
  7 + use crate::memory::physical::zone::MemoryRegionType;
    |
  7 + use crate::memory::vm::address_space::MemoryRegionType;
    |
help: if you import `MemoryRegionType`, refer to it directly
    |
122 -             crate::memory::virtual_mem::MemoryRegionType::Mmap,
122 +             MemoryRegionType::Mmap,
    |

error[E0433]: failed to resolve: could not find `MemoryRegionInfo` in `virtual_mem`
   --> kernel\src\memory\shared\mod.rs:123:41
    |
123 |             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
    |                                         ^^^^^^^^^^^^^^^^ could not find `MemoryRegionInfo` in `virtual_mem`
    |
help: a struct with a similar name exists
    |
123 -             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
123 +             crate::memory::virtual_mem::MemoryRegion::Mmap {
    |
help: consider importing this enum
    |
  7 + use crate::memory::vm::address_space::MemoryRegionInfo;
    |
help: if you import `MemoryRegionInfo`, refer to it directly
    |
123 -             crate::memory::virtual_mem::MemoryRegionInfo::Mmap {
123 +             MemoryRegionInfo::Mmap {
    |

error[E0412]: cannot find type `Vec` in this scope
   --> kernel\src\memory\shared\mod.rs:186:54
    |
186 |     pub fn list_shared_memory(&self) -> MemoryResult<Vec<SharedMemoryInfo>> {
    |                                                      ^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0433]: failed to resolve: use of undeclared type `Vec`
   --> kernel\src\memory\shared\mod.rs:189:38
    |
189 |         let mut shared_memory_list = Vec::new();
    |                                      ^^^ use of undeclared type `Vec`
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0412]: cannot find type `Vec` in this scope
   --> kernel\src\memory\shared\mod.rs:301:45
    |
301 | pub fn list_shared_memory() -> MemoryResult<Vec<SharedMemoryInfo>> {
    |                                             ^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  7 + use crate::prelude::vec::Vec;
    |
  7 + use alloc::vec::Vec;
    |

error[E0425]: cannot find function `dealloc_aligned` in module `crate::memory::heap`
   --> kernel\src\memory\cache.rs:224:26
    |
224 |     crate::memory::heap::dealloc_aligned(aligned_data);
    |                          ^^^^^^^^^^^^^^^ help: a function with a similar name exists: `alloc_aligned`
    |
   ::: kernel\src\memory\heap\mod.rs:166:1
    |
166 | pub fn alloc_aligned(size: usize, alignment: usize) -> MemoryResult<NonNull<u8>> {
    | -------------------------------------------------------------------------------- similarly named function `alloc_aligned` defined here

error[E0425]: cannot find function `physical_to_virtual` in module `crate::memory::virtual_mem`
   --> kernel\src\memory\dma.rs:365:56
    |
365 |         let virtual_addr = crate::memory::virtual_mem::physical_to_virtual(physical_frame.address())?;
    |                                                        ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory::virtual_mem`

error[E0425]: cannot find function `physical_to_virtual` in module `crate::memory::virtual_mem`
   --> kernel\src\memory\mmap.rs:365:56
    |
365 |         let virtual_addr = crate::memory::virtual_mem::physical_to_virtual(physical_frame.address())?;
    |                                                        ^^^^^^^^^^^^^^^^^^^ not found in `crate::memory::virtual_mem`

error[E0412]: cannot find type `HbaCap` in this scope
  --> kernel\src\drivers\block\ahci.rs:19:14
   |
19 |     pub cap: HbaCap,        // 0x00
   |              ^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaIs` in this scope
  --> kernel\src\drivers\block\ahci.rs:21:13
   |
21 |     pub is: HbaIs,          // 0x08
   |             ^^^^^ not found in this scope

error[E0412]: cannot find type `HbaPi` in this scope
  --> kernel\src\drivers\block\ahci.rs:22:13
   |
22 |     pub pi: HbaPi,          // 0x0C
   |             ^^^^^ not found in this scope

error[E0412]: cannot find type `HbaVs` in this scope
  --> kernel\src\drivers\block\ahci.rs:23:13
   |
23 |     pub vs: HbaVs,          // 0x10
   |             ^^^^^ not found in this scope

error[E0412]: cannot find type `HbaCccCtl` in this scope
  --> kernel\src\drivers\block\ahci.rs:24:18
   |
24 |     pub ccc_ctl: HbaCccCtl, // 0x14
   |                  ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaCccPts` in this scope
  --> kernel\src\drivers\block\ahci.rs:25:18
   |
25 |     pub ccc_pts: HbaCccPts, // 0x18
   |                  ^^^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaEmLoc` in this scope
  --> kernel\src\drivers\block\ahci.rs:26:17
   |
26 |     pub em_loc: HbaEmLoc,   // 0x1C
   |                 ^^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaEmCtl` in this scope
  --> kernel\src\drivers\block\ahci.rs:27:17
   |
27 |     pub em_ctl: HbaEmCtl,   // 0x20
   |                 ^^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaCap2` in this scope
  --> kernel\src\drivers\block\ahci.rs:28:15
   |
28 |     pub cap2: HbaCap2,      // 0x24
   |               ^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaBohc` in this scope
   --> kernel\src\drivers\block\ahci.rs:29:15
    |
 29 |       pub bohc: HbaBohc,      // 0x28
    |                 ^^^^^^^ help: a struct with a similar name exists: `HbaGhc`
...
228 | / bitflags! {
229 | |     pub struct HbaGhc: u32 { const HR = 1 << 0; const IE = 1 << 1; const MRSM = 1 << 2; const AE = 1 << 31; const CR = 1 << 0; }
230 | | }
    | |_- similarly named struct `HbaGhc` defined here

error[E0412]: cannot find type `HbaPort` in this scope
  --> kernel\src\drivers\block\ahci.rs:33:17
   |
33 |     pub ports: [HbaPort; 32], // 0xA0 - 0xFF
   |                 ^^^^^^^ not found in this scope

error[E0412]: cannot find type `HbaPort` in this scope
   --> kernel\src\drivers\block\ahci.rs:108:24
    |
108 |     registers: NonNull<HbaPort>,
    |                        ^^^^^^^ not found in this scope
    |
help: you might be missing a type parameter
    |
104 | struct AhciPortDriver<HbaPort> {
    |                      +++++++++

error[E0412]: cannot find type `HbaPort` in this scope
   --> kernel\src\drivers\block\ahci.rs:220:47
    |
220 |     fn detect_device_type(_port_regs: NonNull<HbaPort>) -> AhciDeviceType {
    |                                               ^^^^^^^ not found in this scope
    |
help: you might be missing a type parameter
    |
125 | impl<HbaPort> AhciDriver {
    |     +++++++++

error[E0412]: cannot find type `NvmeCap` in this scope
  --> kernel\src\drivers\block\nvme.rs:20:14
   |
20 |       pub cap: NvmeCap,        // 0x00: Controller Capabilities
   |                ^^^^^^^ help: a struct with a similar name exists: `NvmeCc`
...
63 | / bitflags! {
64 | |     pub struct NvmeCc: u32 {
65 | |         const EN = 1 << 0; // Enable
66 | |         const CSS = 0b111 << 4; // I/O Command Set Selected
...  |
73 | | }
   | |_- similarly named struct `NvmeCc` defined here

error[E0412]: cannot find type `NvmeVs` in this scope
  --> kernel\src\drivers\block\nvme.rs:21:13
   |
21 |       pub vs: NvmeVs,          // 0x08: Version
   |               ^^^^^^ help: a struct with a similar name exists: `NvmeCc`
...
63 | / bitflags! {
64 | |     pub struct NvmeCc: u32 {
65 | |         const EN = 1 << 0; // Enable
66 | |         const CSS = 0b111 << 4; // I/O Command Set Selected
...  |
73 | | }
   | |_- similarly named struct `NvmeCc` defined here

error[E0412]: cannot find type `NvmeAqa` in this scope
  --> kernel\src\drivers\block\nvme.rs:27:14
   |
27 |     pub aqa: NvmeAqa,        // 0x24: Admin Queue Attributes
   |              ^^^^^^^ not found in this scope

error[E0433]: failed to resolve: use of undeclared type `Vec`
   --> kernel\src\drivers\input\keyboard.rs:131:26
    |
131 |         let mut events = Vec::new();
    |                          ^^^ use of undeclared type `Vec`
    |
help: consider importing one of these structs
    |
  6 + use crate::drivers::Vec;
    |
  6 + use alloc::vec::Vec;
    |

error[E0425]: cannot find value `BLUE` in module `colors`
   --> kernel\src\drivers\video\vga.rs:179:31
    |
179 |             c if c == colors::BLUE => VgaColor::Blue,
    |                               ^^^^ not found in `colors`

error[E0425]: cannot find value `YELLOW` in module `colors`
   --> kernel\src\drivers\video\vga.rs:180:31
    |
180 |             c if c == colors::YELLOW => VgaColor::Yellow,
    |                               ^^^^^^ not found in `colors`

error[E0412]: cannot find type `PixelFormat` in this scope
  --> kernel\src\drivers\video\mod.rs:29:35
   |
29 |     fn get_pixel_format(&self) -> PixelFormat;
   |                                   ^^^^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
22 +     use crate::drivers::video::PixelFormat;
   |

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:32:75
   |
32 |     fn set_pixel(&mut self, x: usize, y: usize, color: u32) -> Result<(), VideoError>;
   |                                                                           ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
32 |     fn set_pixel<VideoError>(&mut self, x: usize, y: usize, color: u32) -> Result<(), VideoError>;
   |                 ++++++++++++

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:36:107
   |
36 |     fn write_block(&mut self, x: usize, y: usize, width: usize, height: usize, data: &[u8]) -> Result<(), VideoError>;
   |                                                                                                           ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
36 |     fn write_block<VideoError>(&mut self, x: usize, y: usize, width: usize, height: usize, data: &[u8]) -> Result<(), VideoError>;
   |                   ++++++++++++

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:39:64
   |
39 |     fn set_cursor(&mut self, x: usize, y: usize) -> Result<(), VideoError>;
   |                                                                ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
39 |     fn set_cursor<VideoError>(&mut self, x: usize, y: usize) -> Result<(), VideoError>;
   |                  ++++++++++++

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:42:53
   |
42 |     fn write_char(&mut self, c: char) -> Result<(), VideoError>;
   |                                                     ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
42 |     fn write_char<VideoError>(&mut self, c: char) -> Result<(), VideoError>;
   |                  ++++++++++++

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:45:51
   |
45 |     fn clear(&mut self, color: u32) -> Result<(), VideoError>;
   |                                                   ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
45 |     fn clear<VideoError>(&mut self, color: u32) -> Result<(), VideoError>;
   |             ++++++++++++

error[E0412]: cannot find type `VideoError` in this scope
  --> kernel\src\drivers\video\mod.rs:48:46
   |
48 |     fn swap_buffers(&mut self) -> Result<(), VideoError>;
   |                                              ^^^^^^^^^^ not found in this scope
   |
help: you might be missing a type parameter
   |
48 |     fn swap_buffers<VideoError>(&mut self) -> Result<(), VideoError>;
   |                    ++++++++++++

error[E0405]: cannot find trait `VideoDriver` in this scope
  --> kernel\src\drivers\video\mod.rs:65:34
   |
65 |     driver: Option<Arc<Mutex<dyn VideoDriver>>>,
   |                                  ^^^^^^^^^^^ not found in this scope

error[E0405]: cannot find trait `VideoDriver` in this scope
   --> kernel\src\drivers\video\mod.rs:106:47
    |
106 | pub fn get_driver() -> &'static Arc<Mutex<dyn VideoDriver>> {
    |                                               ^^^^^^^^^^^ not found in this scope

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
  --> kernel\src\logger.rs:86:37
   |
86 |             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
   |                                     ^^^^^^^^ could not find `c_compat` in the crate root
   |
help: consider importing this struct
   |
 6 + use uart_16550::SerialPort;
   |
help: if you import `SerialPort`, refer to it directly
   |
86 -             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
86 +             let mut serial = SerialPort::new(0x3F8);
   |

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
   --> kernel\src\logger.rs:100:33
    |
100 |         let mut serial = crate::c_compat::SerialPort::new(0x3F8);
    |                                 ^^^^^^^^ could not find `c_compat` in the crate root
    |
help: consider importing this struct
    |
  6 + use uart_16550::SerialPort;
    |
help: if you import `SerialPort`, refer to it directly
    |
100 -         let mut serial = crate::c_compat::SerialPort::new(0x3F8);
100 +         let mut serial = SerialPort::new(0x3F8);
    |

error[E0433]: failed to resolve: could not find `c_compat` in the crate root
   --> kernel\src\logger.rs:129:37
    |
129 |             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
    |                                     ^^^^^^^^ could not find `c_compat` in the crate root
    |
help: consider importing this struct
    |
  6 + use uart_16550::SerialPort;
    |
help: if you import `SerialPort`, refer to it directly
    |
129 -             let mut serial = crate::c_compat::SerialPort::new(0x3F8);
129 +             let mut serial = SerialPort::new(0x3F8);
    |

error[E0603]: struct import `PciDevice` is private
   --> kernel\src\drivers\pci\mod.rs:21:38
    |
 21 | pub use enumeration::{enumerate_bus, PciDevice};
    |                                      ^^^^^^^^^ private struct import
    |
note: the struct import `PciDevice` is defined here...
   --> kernel\src\drivers\pci\enumeration.rs:6:25
    |
  6 | use super::{PciAddress, PciDevice, PciClassCode};
    |                         ^^^^^^^^^
note: ...and refers to the struct `PciDevice` which is defined here
   --> kernel\src\drivers\pci\mod.rs:126:1
    |
126 | pub struct PciDevice {
    | ^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: import `PciDevice` directly
    |
 21 | pub use enumeration::{enumerate_bus, drivers::pci::PciDevice};
    |                                      ++++++++++++++

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\mod.rs:425:22
    |
425 | pub use page_table::{PageTableFlags as VmFlags}; // Alias VmFlags
    |                      ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: import `PageTableFlags` directly
    |
425 - pub use page_table::{PageTableFlags as VmFlags}; // Alias VmFlags
425 + pub use page_table::{memory::virtual_mem::PageTableFlags}; // Alias VmFlags
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\address_space.rs:192:44
    |
192 |             let flags = super::page_table::PageTableFlags::new()
    |                                            ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
192 -             let flags = super::page_table::PageTableFlags::new()
192 +             let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
192 -             let flags = super::page_table::PageTableFlags::new()
192 +             let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\address_space.rs:201:48
    |
201 |                 let flags = super::page_table::PageTableFlags::new()
    |                                                ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
201 -                 let flags = super::page_table::PageTableFlags::new()
201 +                 let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
201 -                 let flags = super::page_table::PageTableFlags::new()
201 +                 let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: tuple struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:157:48
    |
157 |                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |                                                ^^^^^^^^^^^^^^ private tuple struct import
    |
note: the tuple struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the tuple struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider importing this tuple struct instead
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = crate::memory::virtual_mem::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:157:93
    |
157 |                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
    |                                                                                             ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = super::page_table::PageTableFlags(flags.0 & !crate::memory::vm::PageTableFlags::new().cow().0);
    |
help: import `PageTableFlags` directly
    |
157 -                     flags = super::page_table::PageTableFlags(flags.0 & !super::page_table::PageTableFlags::new().cow().0);
157 +                     flags = super::page_table::PageTableFlags(flags.0 & !memory::virtual_mem::PageTableFlags().cow().0);
    |

error[E0603]: struct import `PageTableFlags` is private
   --> kernel\src\memory\virtual_mem\cow.rs:195:40
    |
195 |         let flags = super::page_table::PageTableFlags::new()
    |                                        ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageTableFlags` is defined here...
   --> kernel\src\memory\virtual_mem\page_table.rs:10:5
    |
 10 | use super::PageTableFlags;
    |     ^^^^^^^^^^^^^^^^^^^^^
note: ...and refers to the struct `PageTableFlags` which is defined here
   --> kernel\src\memory\virtual_mem\mod.rs:26:1
    |
 26 | pub struct PageTableFlags(u64);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
195 -         let flags = super::page_table::PageTableFlags::new()
195 +         let flags = crate::memory::vm::PageTableFlags::new()
    |
help: import `PageTableFlags` directly
    |
195 -         let flags = super::page_table::PageTableFlags::new()
195 +         let flags = memory::virtual_mem::PageTableFlags()
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\dma.rs:416:82
    |
416 | fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
    |                                                                                  ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> crate::memory::PageProtection {
    |
help: import `PageProtection` through the re-export
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> memory::PageProtection {
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\dma.rs:417:49
    |
417 |     let mut flags = crate::memory::virtual_mem::PageProtection::new();
    |                                                 ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = crate::memory::PageProtection::new();
    |
help: import `PageProtection` through the re-export
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = memory::PageProtection();
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\mmap.rs:416:82
    |
416 | fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
    |                                                                                  ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> crate::memory::PageProtection {
    |
help: import `PageProtection` through the re-export
    |
416 - fn convert_protection(protection: MmapProtection) -> crate::memory::virtual_mem::PageProtection {
416 + fn convert_protection(protection: MmapProtection) -> memory::PageProtection {
    |

error[E0603]: struct import `PageProtection` is private
   --> kernel\src\memory\mmap.rs:417:49
    |
417 |     let mut flags = crate::memory::virtual_mem::PageProtection::new();
    |                                                 ^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `PageProtection` is defined here...
   --> kernel\src\memory\virtual_mem\mod.rs:7:81
    |
  7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
    |                                                                                 ^^^^^^^^^^^^^^
note: ...and refers to the struct import `PageProtection` which is defined here...
   --> kernel\src\memory\mod.rs:31:9
    |
 31 | pub use protection::PageProtection;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this re-export
note: ...and refers to the struct `PageProtection` which is defined here
   --> kernel\src\memory\protection.rs:12:1
    |
 12 | pub struct PageProtection(u8);
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct through its public re-export instead
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = crate::memory::PageProtection::new();
    |
help: import `PageProtection` through the re-export
    |
417 -     let mut flags = crate::memory::virtual_mem::PageProtection::new();
417 +     let mut flags = memory::PageProtection();
    |

warning: the feature `core_intrinsics` is internal to the compiler or standard library
  --> kernel\src\lib.rs:10:12
   |
10 | #![feature(core_intrinsics)]
   |            ^^^^^^^^^^^^^^^
   |
   = note: using it is strongly discouraged
   = note: `#[warn(internal_features)]` on by default

warning: unused `#[macro_use]` import
  --> kernel\src\lib.rs:13:1
   |
13 | #[macro_use]
   | ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused `#[macro_use]` import
  --> kernel\src\lib.rs:15:1
   |
15 | #[macro_use]
   | ^^^^^^^^^^^^

warning: unused import: `super::cpuid`
 --> kernel\src\arch\x86_64\cpu\features.rs:9:5
  |
9 | use super::cpuid;
  |     ^^^^^^^^^^^^

warning: unused imports: `read_msr` and `write_msr`
 --> kernel\src\arch\x86_64\cpu\power.rs:6:38
  |
6 | use crate::arch::x86_64::registers::{read_msr, write_msr};
  |                                      ^^^^^^^^  ^^^^^^^^^

warning: unused doc comment
  --> kernel\src\arch\x86_64\memory\mod.rs:42:1
   |
42 | /// Page table flags
   | ^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
   = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `UnmapError`
 --> kernel\src\arch\x86_64\memory\paging.rs:6:34
  |
6 | use super::{MapError, PageFlags, UnmapError};
  |                                  ^^^^^^^^^^

warning: unused import: `super::paging`
  --> kernel\src\arch\x86_64\memory\numa.rs:14:5
   |
14 | use super::paging;
   |     ^^^^^^^^^^^^^

warning: unused imports: `GlobalAlloc` and `Layout`
  --> kernel\src\arch\x86_64\memory\mod.rs:11:19
   |
11 | use core::alloc::{GlobalAlloc, Layout};
   |                   ^^^^^^^^^^^  ^^^^^^

warning: unused import: `core::ptr::NonNull`
  --> kernel\src\arch\x86_64\memory\mod.rs:12:5
   |
12 | use core::ptr::NonNull;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::memory::frame_allocator::FrameAllocator`
  --> kernel\src\arch\x86_64\memory\mod.rs:14:5
   |
14 | use crate::memory::frame_allocator::FrameAllocator;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `bit_field::BitField`
 --> kernel\src\arch\x86_64\interrupts\idt.rs:6:5
  |
6 | use bit_field::BitField;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `core::arch::asm`
 --> kernel\src\arch\x86_64\interrupts\apic.rs:6:5
  |
6 | use core::arch::asm;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `virt_to_phys`
  --> kernel\src\arch\x86_64\interrupts\apic.rs:10:48
   |
10 | use crate::memory::{alloc_pages, phys_to_virt, virt_to_phys, PageFlags};
   |                                                ^^^^^^^^^^^^

warning: unused imports: `phys_to_virt` and `virt_to_phys`
  --> kernel\src\arch\x86_64\interrupts\ioapic.rs:13:21
   |
13 | use crate::memory::{phys_to_virt, virt_to_phys};
   |                     ^^^^^^^^^^^^  ^^^^^^^^^^^^

warning: ambiguous glob re-exports
  --> kernel\src\arch\x86_64\mod.rs:32:9
   |
32 | pub use cpu::*;
   |         ^^^^^^ the name `init` in the value namespace is first re-exported here
33 | pub use memory::*;
34 | pub use interrupts::*;
   |         ------------- but the name `init` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:53:1
   |
53 | /// CR0 register flags
   | ^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:70:1
   |
70 | /// CR4 register flags
   | ^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
  --> kernel\src\arch\x86_64\registers.rs:95:1
   |
95 | /// RFLAGS register flags
   | ^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused doc comment
   --> kernel\src\arch\x86_64\registers.rs:307:1
    |
307 | /// EFER register flags
    | ^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
    |
    = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `cpu::topology::CpuTopology`
  --> kernel\src\arch\x86_64\mod.rs:46:5
   |
46 | use cpu::topology::CpuTopology;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `cpu::features::CpuFeatures`
  --> kernel\src\arch\x86_64\mod.rs:47:5
   |
47 | use cpu::features::CpuFeatures;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `memory::paging::PageTableManager`
  --> kernel\src\arch\x86_64\mod.rs:48:5
   |
48 | use memory::paging::PageTableManager;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `acpi`
  --> kernel\src\boot\mod.rs:17:7
   |
17 | #[cfg(feature = "acpi")]
   |       ^^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `acpi` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
   = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `FrameAllocator`
  --> kernel\src\boot\mod.rs:13:27
   |
13 | use crate::memory::{self, FrameAllocator};
   |                           ^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
 --> kernel\src\boot\multiboot2.rs:6:5
  |
6 | use core::ptr::NonNull;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused imports: `PhysicalMemoryRegion` and `PhysicalMemoryType`
 --> kernel\src\boot\multiboot2.rs:8:21
  |
8 | use crate::memory::{PhysicalMemoryRegion, PhysicalMemoryType};
  |                     ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
 --> kernel\src\boot\phases.rs:6:5
  |
6 | use core::ptr::NonNull;
  |     ^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `acpi`
  --> kernel\src\boot\early_init.rs:56:7
   |
56 | #[cfg(feature = "acpi")]
   |       ^^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `acpi` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `ai`
  --> kernel\src\boot\late_init.rs:83:11
   |
83 |     #[cfg(feature = "ai")]
   |           ^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `ai` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `tpm`
  --> kernel\src\boot\late_init.rs:95:11
   |
95 |     #[cfg(feature = "tpm")]
   |           ^^^^^^^^^^^^^^^
   |
   = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
   = help: consider adding `tpm` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `acpi`
   --> kernel\src\boot\recovery.rs:160:11
    |
160 |     #[cfg(feature = "acpi")]
    |           ^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
    = help: consider adding `acpi` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `acpi`
   --> kernel\src\boot\recovery.rs:187:11
    |
187 |     #[cfg(feature = "acpi")]
    |           ^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `adaptive_drivers`, `bench_auto_exit`, `binary`, `capnp`, `crypto`, `default`, `ed25519-dalek`, `fusion_rings`, `hybrid_allocator`, `post-quantum`, `predictive_scheduler`, `serialization`, `sha3`, and `windowed_context_switch`
    = help: consider adding `acpi` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `AtomicUsize` and `Ordering`
 --> kernel\src\memory\physical\mod.rs:9:26
  |
9 | use core::sync::atomic::{AtomicUsize, Ordering};
  |                          ^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\physical\bitmap_allocator.rs:8:21
  |
8 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\physical\bitmap_allocator.rs:9:5
  |
9 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\physical\buddy_allocator.rs:8:21
  |
8 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\physical\buddy_allocator.rs:9:5
  |
9 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
  --> kernel\src\memory\physical\zone.rs:11:5
   |
11 | use crate::arch;
   |     ^^^^^^^^^^^

warning: unused import: `AtomicUsize`
  --> kernel\src\memory\physical\zone.rs:12:26
   |
12 | use core::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
   |                          ^^^^^^^^^^^

warning: unused imports: `AtomicUsize` and `Ordering`
  --> kernel\src\memory\virtual_mem\page_table.rs:12:26
   |
12 | use core::sync::atomic::{AtomicUsize, Ordering};
   |                          ^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `super::PageTableFlags`
  --> kernel\src\memory\virtual_mem\page_table.rs:15:9
   |
15 | pub use super::PageTableFlags;
   |         ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `PageProtection`
 --> kernel\src\memory\virtual_mem\cow.rs:7:81
  |
7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
  |                                                                                 ^^^^^^^^^^^^^^

warning: unused import: `page_table::PageTable`
   --> kernel\src\memory\virtual_mem\mod.rs:209:5
    |
209 | use page_table::PageTable;
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
  --> kernel\src\memory\heap\mod.rs:10:5
   |
10 | use crate::arch;
   |     ^^^^^^^^^^^

warning: unused import: `MemoryError`
 --> kernel\src\memory\heap\hybrid_allocator.rs:7:35
  |
7 | use crate::memory::{MemoryResult, MemoryError};
  |                                   ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\hybrid_allocator.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\thread_cache.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\cpu_slab.rs:8:5
  |
8 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\heap\slab.rs:6:48
  |
6 | use crate::memory::{MemoryResult, MemoryError, PhysicalAddress, VirtualAddress, phys_to_virt};
  |                                                ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\heap\slab.rs:7:5
  |
7 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\shared\mod.rs:7:21
  |
7 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError, PageProtection};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\shared\pool.rs:6:21
  |
6 | use crate::memory::{PhysicalAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused import: `crate::arch`
 --> kernel\src\memory\shared\pool.rs:7:5
  |
7 | use crate::arch;
  |     ^^^^^^^^^^^

warning: unused import: `PhysicalAddress`
 --> kernel\src\memory\cache.rs:6:21
  |
6 | use crate::memory::{PhysicalAddress, VirtualAddress, MemoryResult, MemoryError};
  |                     ^^^^^^^^^^^^^^^

warning: unused imports: `AllocationOptions` and `PhysicalAddress`
 --> kernel\src\memory\dma.rs:6:37
  |
6 | use crate::memory::{VirtualAddress, PhysicalAddress, MemoryResult, MemoryError, AllocationOptions};
  |                                     ^^^^^^^^^^^^^^^                             ^^^^^^^^^^^^^^^^^

warning: unused imports: `AllocationOptions` and `PhysicalAddress`
 --> kernel\src\memory\mmap.rs:6:37
  |
6 | use crate::memory::{VirtualAddress, PhysicalAddress, MemoryResult, MemoryError, AllocationOptions};
  |                                     ^^^^^^^^^^^^^^^                             ^^^^^^^^^^^^^^^^^

warning: unused import: `core::ptr::NonNull`
  --> kernel\src\memory\mod.rs:73:5
   |
73 | use core::ptr::NonNull;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `spin::Mutex`
  --> kernel\src\drivers\mod.rs:18:5
   |
18 | use spin::Mutex; // Utiliser `spin` pour les mutexes dans un environnement noyau
   |     ^^^^^^^^^^^

warning: unused import: `alloc::vec::Vec`
 --> kernel\src\drivers\block\mod.rs:7:5
  |
7 | use alloc::vec::Vec;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `core::ops::Range`
 --> kernel\src\drivers\block\mod.rs:8:5
  |
8 | use core::ops::Range;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `BlockOpType`
 --> kernel\src\drivers\block\ahci.rs:7:65
  |
7 | use super::{BlockDriver, BlockRequest, BlockError, BlockDevice, BlockOpType};
  |                                                                 ^^^^^^^^^^^

warning: unused import: `BlockOpType`
 --> kernel\src\drivers\block\nvme.rs:8:65
  |
8 | use super::{BlockDriver, BlockRequest, BlockError, BlockDevice, BlockOpType};
  |                                                                 ^^^^^^^^^^^

warning: unused import: `alloc::vec::Vec`
  --> kernel\src\drivers\block\nvme.rs:10:5
   |
10 | use alloc::vec::Vec;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `spin::Mutex`
  --> kernel\src\drivers\block\nvme.rs:13:5
   |
13 | use spin::Mutex;
   |     ^^^^^^^^^^^

warning: unused import: `KeyCode`
 --> kernel\src\drivers\input\hid.rs:7:38
  |
7 | use super::{InputDriver, InputEvent, KeyCode, MouseButton};
  |                                      ^^^^^^^

warning: unused doc comment
  --> kernel\src\drivers\pci\mod.rs:97:1
   |
97 | /// Statut de commande d'un p├⌐riph├⌐rique PCI.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `alloc::vec::Vec`
 --> kernel\src\drivers\pci\mod.rs:9:5
  |
9 | use alloc::vec::Vec;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `crate::drivers::DriverError`
  --> kernel\src\drivers\pci\msi.rs:10:5
   |
10 | use crate::drivers::DriverError;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `alloc::vec::Vec`
  --> kernel\src\drivers\pci\msi.rs:11:5
   |
11 | use alloc::vec::Vec;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `colors`
 --> kernel\src\drivers\video\virtio_gpu.rs:8:51
  |
8 | use super::{VideoDriver, VideoError, PixelFormat, colors};
  |                                                   ^^^^^^

warning: unused import: `alloc::sync::Arc`
 --> kernel\src\drivers\video\virtio_gpu.rs:9:5
  |
9 | use alloc::sync::Arc;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `spin::Mutex`
  --> kernel\src\drivers\video\virtio_gpu.rs:11:5
   |
11 | use spin::Mutex;
   |     ^^^^^^^^^^^

warning: unused import: `framebuffer::FramebufferDriver`
  --> kernel\src\drivers\video\mod.rs:17:5
   |
17 | use framebuffer::FramebufferDriver;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `virtio_gpu::VirtioGpuDriver`
  --> kernel\src\drivers\video\mod.rs:18:5
   |
18 | use virtio_gpu::VirtioGpuDriver;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0107]: missing generics for trait `FrameAllocator`
  --> kernel\src\arch\x86_64\memory\numa.rs:29:47
   |
29 |     pub frame_allocator: Mutex<Option<Box<dyn FrameAllocator>>>,
   |                                               ^^^^^^^^^^^^^^ expected 1 generic argument
   |
note: trait defined here, with 1 generic parameter: `S`
  --> C:\Users\Eric\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\x86_64-0.14.13\src\structures\paging\frame_alloc.rs:12:18
   |
12 | pub unsafe trait FrameAllocator<S: PageSize> {
   |                  ^^^^^^^^^^^^^^ -
help: add missing generic argument
   |
29 |     pub frame_allocator: Mutex<Option<Box<dyn FrameAllocator<S>>>>,
   |                                                             +++

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:210:25
    |
210 |     if let Some(task) = scheduler::current_task() {
    |                         ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:254:25
    |
254 |     if let Some(task) = scheduler::current_task() {
    |                         ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:312:5
    |
312 |     scheduler::handle_timer_tick();
    |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
   --> kernel\src\arch\x86_64\interrupts\handlers.rs:362:5
    |
362 |     scheduler::trigger_reschedule();
    |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
    |
    = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `scheduler`
  --> kernel\src\boot\late_init.rs:14:5
   |
14 |     scheduler::init();
   |     ^^^^^^^^^ use of unresolved module or unlinked crate `scheduler`
   |
   = help: if you wanted to use a crate named `scheduler`, use `cargo add scheduler` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `ipc`
  --> kernel\src\boot\late_init.rs:21:5
   |
21 |     ipc::init();
   |     ^^^ use of unresolved module or unlinked crate `ipc`
   |
   = help: if you wanted to use a crate named `ipc`, use `cargo add ipc` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:29:5
   |
29 |     drivers::init();
   |     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
  --> kernel\src\boot\late_init.rs:32:21
   |
32 |     if let Err(e) = drivers::probe_all() {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
   |
   = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `ipc`
   --> kernel\src\boot\late_init.rs:115:5
    |
115 |     ipc::start_service();
    |     ^^^ use of unresolved module or unlinked crate `ipc`
    |
    = help: if you wanted to use a crate named `ipc`, use `cargo add ipc` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `drivers`
   --> kernel\src\boot\late_init.rs:118:5
    |
118 |     drivers::start_service_manager();
    |     ^^^^^^^ use of unresolved module or unlinked crate `drivers`
    |
    = help: if you wanted to use a crate named `drivers`, use `cargo add drivers` to add it to your `Cargo.toml`

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\dma.rs:227:19
    |
227 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\dma.rs:292:19
    |
292 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\mmap.rs:227:19
    |
227 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `current_process` in this scope
   --> kernel\src\memory\mmap.rs:292:19
    |
292 |     let process = current_process();
    |                   ^^^^^^^^^^^^^^^ not found in this scope

Some errors have detailed explanations: E0107, E0252, E0405, E0412, E0422, E0425, E0432, E0433, E0603.
For more information about an error, try `rustc --explain E0107`.
warning: `exo-kernel` (lib) generated 75 warnings
warning: exo-kernel@0.2.0: Compiled boot.asm with NASM (path src/arch/x86_64/boot/boot.asm)
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled serial.c
warning: exo-kernel@0.2.0: Inherited flag "-mcmodel=kernel" is not supported by the currently used CC
warning: exo-kernel@0.2.0: Compiled windowed.S (provides context_switch symbol)
error: could not compile `exo-kernel` (lib) due to 136 previous errors; 75 warnings emitted
