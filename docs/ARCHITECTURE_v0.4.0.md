# ğŸ—ï¸ ARCHITECTURE - Exo-OS v0.4.0

**Version**: 0.4.0 "Quantum Leap"  
**Date**: 25 novembre 2025  
**Architecture Cible**: x86_64

---

## ğŸ“‹ Table des MatiÃ¨res

1. [Vue d'ensemble](#vue-densemble)
2. [Architecture Globale](#architecture-globale)
3. [Sous-systÃ¨mes Majeurs](#sous-systÃ¨mes-majeurs)
4. [Flux de DonnÃ©es](#flux-de-donnÃ©es)
5. [IntÃ©grations](#intÃ©grations)
6. [Performances](#performances)

---

## ğŸ¯ Vue d'ensemble

Exo-OS v0.4.0 est un microkernel moderne orientÃ© performance et sÃ©curitÃ©, implÃ©mentant :
- **IPC haute performance** via FusionRing zerocopy
- **NUMA-aware memory management**
- **x2APIC/IO-APIC** pour interruptions avancÃ©es
- **VFS cache** avec LRU pour I/O optimal
- **Capability-based security** avec seccomp/pledge/unveil

---

## ğŸ›ï¸ Architecture Globale

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         USERLAND                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Shell  â”‚  â”‚   AI    â”‚  â”‚   Net   â”‚  â”‚  FS Service     â”‚   â”‚
â”‚  â”‚         â”‚  â”‚  Core   â”‚  â”‚ Service â”‚  â”‚                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚           â”‚              â”‚                 â”‚
        â”‚  IPC (FusionRing Zerocopy)                â”‚
        â”‚           â”‚              â”‚                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    KERNEL SPACE (v0.4.0)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚               Syscall Dispatcher                        â”‚    â”‚
â”‚  â”‚  (dispatch.rs - Table de 256 entrÃ©es)                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚      â”‚         â”‚          â”‚          â”‚          â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”          â”‚
â”‚  â”‚Memoryâ”‚  â”‚ Time â”‚  â”‚  I/O  â”‚  â”‚ IPC  â”‚  â”‚Securityâ”‚          â”‚
â”‚  â”‚      â”‚  â”‚      â”‚  â”‚       â”‚  â”‚      â”‚  â”‚        â”‚          â”‚
â”‚  â”‚Â·mmap â”‚  â”‚Â·clockâ”‚  â”‚Â·open  â”‚  â”‚Â·chan â”‚  â”‚Â·caps   â”‚          â”‚
â”‚  â”‚Â·brk  â”‚  â”‚Â·timerâ”‚  â”‚Â·read  â”‚  â”‚Â·shm  â”‚  â”‚Â·pledge â”‚          â”‚
â”‚  â”‚Â·NUMA â”‚  â”‚Â·TSC  â”‚  â”‚Â·VFS   â”‚  â”‚Â·zero â”‚  â”‚Â·unveil â”‚          â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â”‚
â”‚      â”‚        â”‚          â”‚          â”‚          â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚              Core Infrastructure                     â”‚       â”‚
â”‚  â”‚  â€¢ Memory Manager (NUMA, frames, pages)             â”‚       â”‚
â”‚  â”‚  â€¢ Scheduler (CFS, affinity, realtime)              â”‚       â”‚
â”‚  â”‚  â€¢ Interrupts (APIC, IO-APIC, x2APIC)               â”‚       â”‚
â”‚  â”‚  â€¢ Security (Capabilities, Credentials)             â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Sous-systÃ¨mes Majeurs

### 1. Memory Management

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Memory Subsystem                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Virtual Mem  â”‚â”€â”€â”€â”€â–¶â”‚  Page Table  â”‚                  â”‚
â”‚  â”‚  (mmap mgr)  â”‚     â”‚   (x86_64)   â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚         â”‚                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Physical Mem â”‚â”€â”€â”€â”€â–¶â”‚ Frame Alloc  â”‚                  â”‚
â”‚  â”‚  (NUMA-aware)â”‚     â”‚ (zone-based) â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                           â”‚
â”‚  Syscalls: mmap, munmap, mprotect, brk, madvise,        â”‚
â”‚            mlock, munlock, mremap                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Composants ClÃ©s

1. **MmapManager** (`memory/mmap.rs`)
   - GÃ¨re les mappings virtuels
   - Tracks: addr, size, permissions, flags
   - IntÃ©gration page_table pour mapping effectif

2. **NUMA Allocator** (`memory/physical/numa.rs`)
   - `NumaAllocator::allocate_from_node(node)` - Allocation locale
   - `closest_node(cpu_id)` - CPUâ†’Node mapping
   - Structure: `NumaNodeInfo { base_addr, size, free_frames }`

3. **Zerocopy IPC** (`ipc/fusion_ring/zerocopy.rs`)
   - VM range: 0x5000_0000 - 0x6000_0000
   - `ZEROCOPY_MAPPINGS`: Global BTreeMap tracker
   - Reference counting pour shared mappings

#### Flux mmap()

```
sys_mmap(addr, size, prot, flags)
  â”‚
  â”œâ”€â–¶ Validate parameters
  â”‚
  â”œâ”€â–¶ MmapManager::create_mapping()
  â”‚   â”œâ”€â–¶ Find free virtual address
  â”‚   â”œâ”€â–¶ Allocate physical frames (NUMA-aware si possible)
  â”‚   â””â”€â–¶ Update page table entries
  â”‚
  â””â”€â–¶ Return virtual address
```

---

### 2. Time System

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Time Sources                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  TSC   â”‚  â”‚  HPET  â”‚  â”‚  RTC   â”‚            â”‚
â”‚  â”‚ (CPU)  â”‚  â”‚ (MMIO) â”‚  â”‚ (CMOS) â”‚            â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚
â”‚      â”‚           â”‚           â”‚                  â”‚
â”‚  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚      Time Abstraction Layer     â”‚            â”‚
â”‚  â”‚  â€¢ uptime_ns()                  â”‚            â”‚
â”‚  â”‚  â€¢ unix_timestamp()             â”‚            â”‚
â”‚  â”‚  â€¢ busy_sleep_ns()              â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                  â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚      Timer Subsystem            â”‚            â”‚
â”‚  â”‚  TIMERS: BTreeMap<TimerId, T>  â”‚            â”‚
â”‚  â”‚  â€¢ Periodic timers              â”‚            â”‚
â”‚  â”‚  â€¢ One-shot timers              â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                  â”‚
â”‚  Syscalls: clock_gettime, nanosleep,           â”‚
â”‚            timer_create, alarm                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Flux clock_gettime()

```
sys_clock_gettime(clock_id, &timespec)
  â”‚
  â”œâ”€â–¶ match clock_id:
  â”‚   â”œâ”€â–¶ REALTIME    â†’ time::unix_timestamp()
  â”‚   â”œâ”€â–¶ MONOTONIC   â†’ time::uptime_ns()
  â”‚   â”œâ”€â–¶ PROCESS_CPU â†’ tsc::read_tsc() / CPU
  â”‚   â””â”€â–¶ THREAD_CPU  â†’ tsc::read_tsc() / thread
  â”‚
  â””â”€â–¶ Write timespec to user memory
```

---

### 3. I/O & VFS

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               I/O Subsystem                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  File Descriptor Table          â”‚             â”‚
â”‚  â”‚  FD_TABLE: BTreeMap<Fd, FD>    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚         VFS Layer                â”‚             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚             â”‚
â”‚  â”‚  â”‚  Inode   â”‚  â”‚  Dentry  â”‚    â”‚             â”‚
â”‚  â”‚  â”‚  Cache   â”‚  â”‚  Cache   â”‚    â”‚             â”‚
â”‚  â”‚  â”‚ (LRU)    â”‚  â”‚ (HashMap)â”‚    â”‚             â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚      Filesystem Backends         â”‚             â”‚
â”‚  â”‚  â€¢ tmpfs  â€¢ procfs  â€¢ sysfs     â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                   â”‚
â”‚  Special Devices:                                â”‚
â”‚  â€¢ stdout/stderr â†’ Serial Console (COM1)         â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### VFS Cache Design

**InodeCache** (1024 entries):
- Structure: `HashMap<inode, CacheEntry> + VecDeque<inode>` (LRU)
- `get()` - Move to front on hit
- `insert()` - Evict oldest on capacity
- Dirty tracking pour write-back

**DentryCache** (2048 entries):
- Structure: `HashMap<path, inode>`
- Random eviction (simple policy)
- Path resolution acceleration

#### Flux read()

```
sys_read(fd, buf, count)
  â”‚
  â”œâ”€â–¶ FD_TABLE.get(fd) â†’ FileDescriptor
  â”‚
  â”œâ”€â–¶ Special case: fd 1/2 â†’ Serial console
  â”‚
  â”œâ”€â–¶ VFS lookup: inode from FD
  â”‚   â”œâ”€â–¶ InodeCache.get(inode)
  â”‚   â”‚   â”œâ”€â–¶ Cache hit â†’ return data
  â”‚   â”‚   â””â”€â–¶ Cache miss â†’ load from backend
  â”‚   â”‚
  â”‚   â””â”€â–¶ Read data from inode
  â”‚
  â””â”€â–¶ Copy to user buffer, update offset
```

---

### 4. APIC/IO-APIC (Interruptions)

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Interrupt Architecture                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚      IDT (Interrupt Desc Table) â”‚             â”‚
â”‚  â”‚      256 entries (idt.rs)       â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚        Local APIC               â”‚             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚             â”‚
â”‚  â”‚  â”‚  xAPIC   â”‚  â”‚ x2APIC   â”‚    â”‚             â”‚
â”‚  â”‚  â”‚  (MMIO)  â”‚  â”‚  (MSR)   â”‚    â”‚             â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚             â”‚
â”‚  â”‚  â€¢ EOI (End-of-Interrupt)      â”‚             â”‚
â”‚  â”‚  â€¢ Spurious vector config      â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚         I/O APIC                â”‚             â”‚
â”‚  â”‚  Base: 0xFEC00000 (MMIO)       â”‚             â”‚
â”‚  â”‚  â€¢ IRQ routing (IOREDTBL)      â”‚             â”‚
â”‚  â”‚  â€¢ IRQ masking                  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### MSR Access Implementation

```rust
// Custom implementation (core::arch::x86_64 n'exporte pas _rdmsr)
pub unsafe fn rdmsr(msr: u32) -> u64 {
    let (low, high): (u32, u32);
    core::arch::asm!(
        "rdmsr",
        in("ecx") msr,
        out("eax") low,
        out("edx") high,
        options(nomem, nostack)
    );
    ((high as u64) << 32) | (low as u64)
}
```

#### x2APIC vs xAPIC

| Feature | xAPIC (MMIO) | x2APIC (MSR) |
|---------|--------------|--------------|
| Address | 0xFEE00000 | MSR 0x800+ |
| Speed | ~100 cycles | ~10 cycles |
| APIC ID | 8-bit | 32-bit |
| Detection | CPUID leaf 1, ECX bit 21 | Same |
| EOI | Write 0 to [base+0xB0] | Write 0 to MSR 0x80B |

---

### 5. Security

#### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Security Subsystem                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    Capability System            â”‚             â”‚
â”‚  â”‚  PROCESS_CAPS: BTreeMap<pid,   â”‚             â”‚
â”‚  â”‚                Vec<Capability>> â”‚             â”‚
â”‚  â”‚  â€¢ Grant/Revoke/Check           â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Process Credentials           â”‚             â”‚
â”‚  â”‚  PROCESS_CREDS: BTreeMap<pid,   â”‚             â”‚
â”‚  â”‚                 Credentials>    â”‚             â”‚
â”‚  â”‚  â€¢ UID/GID/EUID/EGID            â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚              â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    Restriction Layers           â”‚             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚             â”‚
â”‚  â”‚  â”‚ seccomp  â”‚  â”‚  pledge  â”‚    â”‚             â”‚
â”‚  â”‚  â”‚ (syscall)â”‚  â”‚ (promise)â”‚    â”‚             â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚             â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚             â”‚
â”‚  â”‚  â”‚  unveil  â”‚                  â”‚             â”‚
â”‚  â”‚  â”‚   (fs)   â”‚                  â”‚             â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Capability Flow

```
Process A wants to grant capability to Process B:

sys_grant_capability(pid_B, CAP_TYPE, target)
  â”‚
  â”œâ”€â–¶ Check: Current process has GRANT permission?
  â”‚
  â”œâ”€â–¶ Create Capability:
  â”‚   {
  â”‚     id: unique_id,
  â”‚     cap_type: CAP_TYPE,
  â”‚     target: resource_id,
  â”‚     valid: true
  â”‚   }
  â”‚
  â”œâ”€â–¶ PROCESS_CAPS[pid_B].push(capability)
  â”‚
  â””â”€â–¶ Return capability_id
```

#### Restriction Layers

1. **seccomp** - Syscall filtering
   - STRICT mode: Only read/write/exit/sigreturn
   - FILTER mode: BPF program filtering

2. **pledge** - OpenBSD-style promises
   - `stdio`: Basic I/O
   - `rpath/wpath`: Filesystem read/write
   - `inet/unix`: Network sockets
   - `proc/exec`: Process control

3. **unveil** - Filesystem restrictions
   - Per-path permissions: r/w/x/c
   - Locked after first unveil(NULL)

---

## ğŸ”„ Flux de DonnÃ©es

### Syscall Complete Flow

```
Userspace
  â”‚
  â”‚  syscall(number, args...)
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Syscall Entry (arch/x86_64/syscall.rs) â”‚
â”‚  â€¢ Save context                         â”‚
â”‚  â€¢ Switch to kernel stack               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Validation (syscall/entry/validation)  â”‚
â”‚  â€¢ Check syscall number < 256           â”‚
â”‚  â€¢ Validate pointer arguments           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dispatcher (syscall/dispatch.rs)       â”‚
â”‚  â€¢ SYSCALL_TABLE[number]()              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Handler (syscall/handlers/*.rs)        â”‚
â”‚  â€¢ Process-specific logic               â”‚
â”‚  â€¢ Call subsystem (memory/time/io/etc)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Subsystem Core                         â”‚
â”‚  â€¢ Execute operation                    â”‚
â”‚  â€¢ Update state                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Return to Userspace                    â”‚
â”‚  â€¢ Restore context                      â”‚
â”‚  â€¢ sysret                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### IPC Zerocopy Flow

```
Process A sends large message (>56B) to Process B:

1. Process A: channel_send(msg)
   â”‚
   â”œâ”€â–¶ FusionRing: Size > 56B? â†’ Zerocopy path
   â”‚
   â”œâ”€â–¶ map_shared(size):
   â”‚   â”œâ”€â–¶ Allocate physical frames
   â”‚   â”œâ”€â–¶ Find free VM in 0x5000_0000 range
   â”‚   â”œâ”€â–¶ Map pages in both processes
   â”‚   â””â”€â–¶ ZEROCOPY_MAPPINGS[vaddr] = { phys, size, ref=2 }
   â”‚
   â””â”€â–¶ Write pointer to ring, not data

2. Process B: channel_recv()
   â”‚
   â”œâ”€â–¶ FusionRing: Read pointer from ring
   â”‚
   â”œâ”€â–¶ Access shared memory directly
   â”‚   (Already mapped in address space)
   â”‚
   â””â”€â–¶ unmap_shared(vaddr):
       â”œâ”€â–¶ Decrement ref count
       â””â”€â–¶ If ref == 0: Free physical frames
```

---

## ğŸ”— IntÃ©grations

### Memory â†” NUMA

```rust
// Allocation NUMA-aware dans physical allocator
let node = numa::closest_node(current_cpu());
let frame = NumaAllocator::allocate_from_node(node)?;
```

### Time â†” Scheduler

```rust
// Scheduler utilise TSC pour time slicing
let start_tsc = time::tsc::read_tsc();
// ... run thread ...
let elapsed = time::tsc::read_tsc() - start_tsc;
thread.cpu_time += elapsed;
```

### VFS â†” Security

```rust
// open() vÃ©rifie unveil permissions
let path = "/etc/passwd";
if !security::check_unveil(current_pid(), path, "r") {
    return Err(PermissionDenied);
}
```

### APIC â†” Scheduler

```rust
// Timer interrupt â†’ scheduler tick
fn timer_interrupt_handler() {
    apic::send_eoi();  // Acknowledge interrupt
    scheduler::tick();  // Trigger rescheduling
}
```

---

## âš¡ Performances

### Optimisations ClÃ©s

1. **Zerocopy IPC**
   - 0 copies pour messages >56B
   - Throughput: ~10GB/s (limite hardware)

2. **NUMA-aware allocation**
   - Latence rÃ©duite: local > remote (factor 2-3x)
   - Automatic node detection

3. **VFS Cache**
   - Hit rate: ~95% (typical workload)
   - Latence: ~10ns (cache hit) vs ~1000ns (disk)

4. **x2APIC**
   - EOI latency: ~10 cycles vs ~100 (xAPIC)
   - Critical pour high-frequency interrupts

### Benchmarks (estimÃ©s)

| Operation | Latency | Throughput |
|-----------|---------|------------|
| Syscall overhead | ~50ns | 20M ops/s |
| Context switch | ~2Âµs | 500K/s |
| IPC zerocopy | ~100ns | 10GB/s |
| mmap() | ~1Âµs | 1M ops/s |
| VFS cache hit | ~10ns | 100M ops/s |

---

## ğŸ“š RÃ©fÃ©rences

- **x86_64 Manual**: Intel SDM Volume 3
- **ACPI Spec**: ACPI 6.4 (SRAT, HPET tables)
- **POSIX**: IEEE Std 1003.1-2017
- **VFS Design**: Linux VFS documentation

---

*Document gÃ©nÃ©rÃ© pour Exo-OS v0.4.0 - 25 novembre 2025*
